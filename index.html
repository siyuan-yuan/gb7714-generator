<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GB/T 7714-2015 å‚è€ƒæ–‡çŒ®ç”Ÿæˆå™¨ (å…¨èƒ½ç‰ˆ)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --gradient-start: #6366f1;
            --gradient-end: #8b5cf6;
        }
        
        body { 
            font-family: 'Inter', -apple-system, system-ui, sans-serif; 
            background: linear-gradient(135deg, #f0f4ff 0%, #faf5ff 50%, #fff1f2 100%);
            min-height: 100vh;
        }
        
        .reference-output { 
            font-family: "Times New Roman", Georgia, serif; 
            line-height: 1.8; 
        }
        
        .journal-name { 
            font-style: italic; 
        }
        
        .glass-card {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        
        .gradient-header {
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.35);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.45);
        }
        
        .btn-secondary {
            transition: all 0.3s ease;
        }
        
        .btn-secondary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .input-field {
            transition: all 0.3s ease;
            border: 2px solid #e5e7eb;
        }
        
        .input-field:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
            outline: none;
        }
        
        .tab-btn {
            position: relative;
            transition: all 0.3s ease;
        }
        
        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--gradient-start), var(--gradient-end));
            border-radius: 3px 3px 0 0;
        }
        
        .output-card {
            background: linear-gradient(145deg, #fafbff 0%, #f8f9fc 100%);
            border: 1px solid rgba(99, 102, 241, 0.1);
        }
        
        .reference-item {
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .reference-item:hover {
            background: rgba(99, 102, 241, 0.05);
            border-left-color: var(--primary);
        }
        
        .floating-icon {
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .pulse-dot {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .copy-btn {
            transition: all 0.2s ease;
        }
        
        .copy-btn:hover {
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: white;
            border-color: transparent;
        }
        
        .bibtex-output {
            background: linear-gradient(145deg, #1e1e2e 0%, #2d2d3f 100%);
            color: #a6e3a1;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        
        .decorated-border {
            position: relative;
        }
        
        .decorated-border::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--gradient-start), var(--gradient-end), #ec4899);
            border-radius: 12px 12px 0 0;
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">
    <!-- Decorative Background Elements -->
    <div class="fixed inset-0 overflow-hidden pointer-events-none">
        <div class="absolute top-20 left-10 w-72 h-72 bg-purple-200 rounded-full mix-blend-multiply filter blur-3xl opacity-30 floating-icon"></div>
        <div class="absolute top-40 right-10 w-72 h-72 bg-indigo-200 rounded-full mix-blend-multiply filter blur-3xl opacity-30 floating-icon" style="animation-delay: 2s;"></div>
        <div class="absolute bottom-20 left-1/3 w-72 h-72 bg-pink-200 rounded-full mix-blend-multiply filter blur-3xl opacity-30 floating-icon" style="animation-delay: 4s;"></div>
    </div>

    <div class="max-w-4xl mx-auto relative">
        <!-- Main Card -->
        <div class="glass-card rounded-3xl shadow-2xl overflow-hidden decorated-border">
            <!-- Header -->
            <header class="gradient-header p-8 text-white relative overflow-hidden">
                <div class="absolute inset-0 opacity-10">
                    <svg class="w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <defs>
                            <pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse">
                                <path d="M 10 0 L 0 0 0 10" fill="none" stroke="white" stroke-width="0.5"/>
                            </pattern>
                        </defs>
                        <rect width="100" height="100" fill="url(#grid)"/>
                    </svg>
                </div>
                <div class="relative">
                    <div class="flex items-center gap-3 mb-3">
                        <div class="w-12 h-12 bg-white/20 rounded-xl flex items-center justify-center backdrop-blur-sm">
                            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                            </svg>
                        </div>
                        <div>
                            <h1 class="text-2xl md:text-3xl font-bold tracking-tight">GB/T 7714-2015</h1>
                            <p class="text-white/80 text-sm md:text-base">å‚è€ƒæ–‡çŒ®æ ¼å¼ç”Ÿæˆå™¨</p>
                        </div>
                    </div>
                    <div class="flex flex-wrap gap-2 mt-4">
                        <span class="px-3 py-1 bg-white/20 rounded-full text-sm backdrop-blur-sm">APA</span>
                        <span class="px-3 py-1 bg-white/20 rounded-full text-sm backdrop-blur-sm">MLA</span>
                        <span class="px-3 py-1 bg-white/20 rounded-full text-sm backdrop-blur-sm">IEEE</span>
                        <span class="px-3 py-1 bg-white/20 rounded-full text-sm backdrop-blur-sm">BibTeX</span>
                    </div>
                </div>
            </header>

            <main class="p-6 md:p-8 space-y-8">
                <!-- Mode Toggle -->
                <div class="flex gap-2 p-1.5 bg-gray-100 rounded-2xl">
                    <button id="tab-auto" class="tab-btn active flex-1 px-6 py-3 rounded-xl text-indigo-700 font-semibold bg-white shadow-sm" onclick="switchTab('auto')">
                        <div class="flex items-center justify-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                            </svg>
                            <span>æ™ºèƒ½è½¬æ¢</span>
                        </div>
                    </button>
                    <button id="tab-manual" class="tab-btn flex-1 px-6 py-3 rounded-xl text-gray-500 font-medium" onclick="switchTab('manual')">
                        <div class="flex items-center justify-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
                            </svg>
                            <span>æ‰‹åŠ¨å½•å…¥</span>
                        </div>
                    </button>
                </div>

                <!-- Auto Convert Section -->
                <div id="section-auto" class="space-y-5">
                    <div class="relative">
                        <label class="flex items-center gap-2 text-sm font-semibold text-gray-700 mb-3">
                            <span class="w-2 h-2 bg-indigo-500 rounded-full pulse-dot"></span>
                            è¾“å…¥å‚è€ƒæ–‡çŒ® (æ¯è¡Œä¸€æ¡)
                        </label>
                        <textarea id="input-raw" rows="8" class="input-field w-full p-4 rounded-2xl bg-white/80 resize-none text-gray-700 placeholder-gray-400" placeholder="ç²˜è´´æ‚¨çš„å‚è€ƒæ–‡çŒ®ï¼Œæ”¯æŒ APAã€MLAã€IEEE ç­‰ä¸»æµæ ¼å¼...&#10;&#10;ç¤ºä¾‹ï¼š&#10;Smith, J. (2023). Deep learning for medical imaging. Journal of AI Research, 45(3), 234-251."></textarea>
                        <div class="absolute bottom-4 right-4 text-xs text-gray-400">
                            <span id="line-count">0</span> æ¡è®°å½•
                        </div>
                    </div>
                    <div class="flex flex-wrap gap-3">
                        <button onclick="convertRaw()" class="btn-primary text-white font-semibold py-3 px-8 rounded-xl flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                            </svg>
                            è½¬æ¢æ ¼å¼
                        </button>
                        <button onclick="loadDemo()" class="btn-secondary bg-white border-2 border-gray-200 text-gray-700 font-medium py-3 px-6 rounded-xl flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                            </svg>
                            å¡«å…¥ç¤ºä¾‹
                        </button>
                        <button onclick="clearInput()" class="btn-secondary bg-white border-2 border-gray-200 text-gray-500 font-medium py-3 px-6 rounded-xl flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                            </svg>
                            æ¸…ç©º
                        </button>
                    </div>
                </div>

                <!-- Manual Input Section -->
                <div id="section-manual" class="space-y-5 hidden">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                        <div class="md:col-span-2">
                            <label class="flex items-center gap-2 text-sm font-semibold text-gray-700 mb-2">
                                <span class="w-2 h-2 bg-purple-500 rounded-full"></span>
                                æ–‡çŒ®ç±»å‹
                            </label>
                            <select id="man-type" class="input-field block w-full rounded-xl p-3 bg-white appearance-none cursor-pointer">
                                <option value="J">ğŸ“„ æœŸåˆŠæ–‡ç«  [J]</option>
                                <option value="C">ğŸ“‹ ä¼šè®®è®ºæ–‡ [C]</option>
                                <option value="M">ğŸ“š ä¸“è‘—/ä¹¦ç± [M]</option>
                            </select>
                        </div>
                        <div class="md:col-span-2">
                            <label class="flex items-center gap-2 text-sm font-semibold text-gray-700 mb-2">
                                <span class="w-2 h-2 bg-blue-500 rounded-full"></span>
                                ä½œè€…
                            </label>
                            <input type="text" id="man-author" class="input-field block w-full rounded-xl p-3 bg-white" placeholder="ä¾‹ï¼šå¼ ä¸‰, æå››">
                        </div>
                        <div class="md:col-span-2">
                            <label class="flex items-center gap-2 text-sm font-semibold text-gray-700 mb-2">
                                <span class="w-2 h-2 bg-green-500 rounded-full"></span>
                                é¢˜å
                            </label>
                            <input type="text" id="man-title" class="input-field block w-full rounded-xl p-3 bg-white" placeholder="æ–‡çŒ®æ ‡é¢˜">
                        </div>
                        <div class="md:col-span-2">
                            <label class="flex items-center gap-2 text-sm font-semibold text-gray-700 mb-2">
                                <span class="w-2 h-2 bg-yellow-500 rounded-full"></span>
                                æ¥æº (åˆŠå/ä¼šè®®å)
                            </label>
                            <input type="text" id="man-source" class="input-field block w-full rounded-xl p-3 bg-white" placeholder="æœŸåˆŠåç§°æˆ–ä¼šè®®åç§°">
                        </div>
                        <div>
                            <label class="text-sm font-medium text-gray-600 mb-2 block">å¹´ä»½</label>
                            <input type="text" id="man-year" class="input-field block w-full rounded-xl p-3 bg-white" placeholder="2024">
                        </div>
                        <div>
                            <label class="text-sm font-medium text-gray-600 mb-2 block">å·(æœŸ)</label>
                            <input type="text" id="man-vol" class="input-field block w-full rounded-xl p-3 bg-white" placeholder="45(3)">
                        </div>
                        <div>
                            <label class="text-sm font-medium text-gray-600 mb-2 block">å‡ºç‰ˆåœ°</label>
                            <input type="text" id="man-city" class="input-field block w-full rounded-xl p-3 bg-white" placeholder="åŒ—äº¬">
                        </div>
                        <div>
                            <label class="text-sm font-medium text-gray-600 mb-2 block">å‡ºç‰ˆç¤¾</label>
                            <input type="text" id="man-publisher" class="input-field block w-full rounded-xl p-3 bg-white" placeholder="ç§‘å­¦å‡ºç‰ˆç¤¾">
                        </div>
                        <div class="md:col-span-2">
                            <label class="text-sm font-medium text-gray-600 mb-2 block">é¡µç </label>
                            <input type="text" id="man-pages" class="input-field block w-full rounded-xl p-3 bg-white" placeholder="100-120">
                        </div>
                    </div>
                    <button onclick="convertManual()" class="btn-primary text-white font-semibold py-3 px-8 rounded-xl flex items-center gap-2 mt-2" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); box-shadow: 0 4px 15px rgba(16, 185, 129, 0.35);">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                        ç”Ÿæˆå¼•ç”¨
                    </button>
                </div>

                <!-- Output Section -->
                <div id="output-container" class="output-card rounded-2xl p-6 hidden space-y-6">
                    <!-- GB/T Output -->
                    <div>
                        <div class="flex justify-between items-center mb-4">
                            <div class="flex items-center gap-3">
                                <div class="w-10 h-10 bg-gradient-to-br from-indigo-500 to-purple-500 rounded-xl flex items-center justify-center">
                                    <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                                    </svg>
                                </div>
                                <div>
                                    <h3 class="text-lg font-bold text-gray-800">GB/T 7714-2015 æ ¼å¼</h3>
                                    <p class="text-sm text-gray-500">å›½æ ‡å‚è€ƒæ–‡çŒ®æ ¼å¼</p>
                                </div>
                            </div>
                            <button onclick="copyOutput('output-content-text')" class="copy-btn text-sm text-indigo-600 font-medium bg-indigo-50 px-4 py-2 rounded-lg border border-indigo-200 flex items-center gap-2">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                                </svg>
                                å¤åˆ¶
                            </button>
                        </div>
                        <div id="output-content-html" class="reference-output text-gray-700 bg-white rounded-xl p-4 border border-gray-100"></div>
                        <textarea id="output-content-text" class="hidden"></textarea>
                    </div>

                    <!-- BibTeX Output -->
                    <div>
                        <div class="flex justify-between items-center mb-4">
                            <div class="flex items-center gap-3">
                                <div class="w-10 h-10 bg-gradient-to-br from-emerald-500 to-teal-500 rounded-xl flex items-center justify-center">
                                    <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"/>
                                    </svg>
                                </div>
                                <div>
                                    <h3 class="text-lg font-bold text-gray-800">BibTeX æ ¼å¼</h3>
                                    <p class="text-sm text-gray-500">LaTeX å¼•ç”¨æ ¼å¼</p>
                                </div>
                            </div>
                            <button onclick="copyBibtex()" class="copy-btn text-sm text-emerald-600 font-medium bg-emerald-50 px-4 py-2 rounded-lg border border-emerald-200 flex items-center gap-2">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                                </svg>
                                å¤åˆ¶
                            </button>
                        </div>
                        <div id="output-bibtex" class="bibtex-output text-sm p-4 rounded-xl overflow-x-auto whitespace-pre"></div>
                    </div>
                </div>
            </main>

            <!-- Footer -->
            <footer class="px-8 py-4 border-t border-gray-100 bg-gray-50/50">
                <p class="text-center text-sm text-gray-500">
                    æ”¯æŒ APA Â· MLA Â· IEEE Â· Chicago ç­‰ä¸»æµå­¦æœ¯æ ¼å¼è‡ªåŠ¨è¯†åˆ«è½¬æ¢
                </p>
            </footer>
        </div>

        <!-- Credits -->
        <p class="text-center text-xs text-gray-400 mt-6">
            GB/T 7714-2015 å‚è€ƒæ–‡çŒ®ç”Ÿæˆå™¨ Â· å…¨èƒ½ç‰ˆ
        </p>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-8 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-6 py-3 rounded-xl shadow-lg opacity-0 transition-opacity duration-300 flex items-center gap-2 pointer-events-none">
        <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
        </svg>
        <span id="toast-message">å·²å¤åˆ¶åˆ°å‰ªè´´æ¿</span>
    </div>

    <script>
        // Update line count
        document.getElementById('input-raw').addEventListener('input', function() {
            const lines = this.value.split('\n').filter(l => l.trim()).length;
            document.getElementById('line-count').textContent = lines;
        });

        function switchTab(mode) {
            const auto = mode === 'auto';
            document.getElementById('section-auto').classList.toggle('hidden', !auto);
            document.getElementById('section-manual').classList.toggle('hidden', auto);
            
            const tabAuto = document.getElementById('tab-auto');
            const tabManual = document.getElementById('tab-manual');
            
            if (auto) {
                tabAuto.className = "tab-btn active flex-1 px-6 py-3 rounded-xl text-indigo-700 font-semibold bg-white shadow-sm";
                tabManual.className = "tab-btn flex-1 px-6 py-3 rounded-xl text-gray-500 font-medium";
            } else {
                tabManual.className = "tab-btn active flex-1 px-6 py-3 rounded-xl text-indigo-700 font-semibold bg-white shadow-sm";
                tabAuto.className = "tab-btn flex-1 px-6 py-3 rounded-xl text-gray-500 font-medium";
            }
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            document.getElementById('toast-message').textContent = message;
            toast.classList.remove('opacity-0');
            toast.classList.add('opacity-100');
            setTimeout(() => {
                toast.classList.remove('opacity-100');
                toast.classList.add('opacity-0');
            }, 2000);
        }

        function clearInput() {
            document.getElementById('input-raw').value = '';
            document.getElementById('line-count').textContent = '0';
            document.getElementById('output-container').classList.add('hidden');
        }

        // --- Core Parsing Logic ---

        function parseAuthorsToObjects(authorStr) {
            if (!authorStr) return [];
            
            // Check for et al, ellipsis (...), or unicode ellipsis (â€¦)
            const hasEtAl = /et\s*al|\.{2,}|â€¦/i.test(authorStr);
            
            // Clean up the string - remove et al, ellipsis, "and others"
            let cleanStr = authorStr
                .replace(/,?\s*(et\s*al\.?|and others)/gi, '')
                .replace(/,?\s*\.{2,}\s*(&|and)?\s*/g, ', ')  // Remove ... and optional & after it
                .replace(/,?\s*â€¦\s*(&|and)?\s*/g, ', ')       // Remove â€¦ (unicode ellipsis)
                .replace(/\s+(&|and)\s+/g, ', ')
                .replace(/[\(\)\[\]"]/g, '')
                .replace(/,\s*,/g, ',')  // Clean up double commas
                .trim()
                .replace(/^,\s*|,\s*$/g, ''); // Remove leading/trailing commas
            
            let segments = cleanStr.split(/,\s*/).filter(s => s.trim());
            let mergedAuthors = [];
            
            for (let i = 0; i < segments.length; i++) {
                let seg = segments[i].trim();
                if (!seg) continue;
                
                // Check if this looks like "Surname" followed by initials/given name
                let isSurnameLike = /^[A-Z][a-z\-\']+$/.test(seg);
                
                if (isSurnameLike && i + 1 < segments.length) {
                    let nextSeg = segments[i+1].trim();
                    // Check if next segment looks like initials or a first name (not another surname pattern)
                    let isInitialsOrName = /^[A-Z]\.?(\s*[A-Z]\.?)*$/.test(nextSeg) || 
                                           /^[A-Z][a-z]+$/.test(nextSeg);
                    if (isInitialsOrName) {
                        mergedAuthors.push({ surname: seg, name: nextSeg });
                        i++; 
                        continue;
                    }
                }
                
                // Check if segment contains space (like "John Smith" or "J. Smith")
                if (seg.includes(' ')) {
                    let parts = seg.split(/\s+/);
                    // Last part is surname
                    mergedAuthors.push({ surname: parts[parts.length - 1], name: parts.slice(0, parts.length - 1).join(' ') });
                } else {
                    // Single name - treat as surname
                    mergedAuthors.push({ surname: seg, name: "" });
                }
            }
            
            mergedAuthors.hasEtAl = hasEtAl;
            return mergedAuthors;
        }

        function formatAuthors(authorStr, lang = 'en') {
            let parsed = parseAuthorsToObjects(authorStr);
            let formatted = parsed.map(a => {
                let s = a.surname.toUpperCase();
                let n = a.name ? a.name.split(/[\s\.\-]+/).filter(p => p).map(p => p.charAt(0).toUpperCase()).join(' ') : "";
                return (s + " " + n).trim();
            });
            if (formatted.length > 3 || (parsed.hasEtAl && formatted.length >= 1)) {
                const suffix = lang === 'zh' ? ", ç­‰" : ", et al";
                return formatted.slice(0, 3).join(', ') + suffix;
            }
            return formatted.join(', ');
        }

        // Format authors for BibTeX - uses "and" connector, "and others" for et al
        function formatAuthorsForBibtex(authorStr) {
            let parsed = parseAuthorsToObjects(authorStr);
            let formatted = parsed.map(a => {
                // BibTeX format: Surname, Firstname
                let surname = a.surname;
                let name = a.name || "";
                if (name) {
                    return `${surname}, ${name}`;
                }
                return surname;
            });
            
            // If there are many authors or has et al, use "and others"
            if (parsed.hasEtAl) {
                if (formatted.length > 3) {
                    return formatted.slice(0, 3).join(' and ') + ' and others';
                }
                return formatted.join(' and ') + ' and others';
            }
            
            return formatted.join(' and ');
        }

        function detectLanguage(text) {
            const chineseChars = (text.match(/[ä¸€-é¾¥]/g) || []).length;
            return chineseChars > 5 ? 'zh' : 'en';
        }

        // Parse MLA Journal format: Authors. "Title." Journal Volume.Issue (Year): Pages.
        function parseMLA_Journal(text) {
            if (!text.includes('"')) return null;
            
            // Extract title in quotes
            const titleMatch = text.match(/"([^"]+)"/);
            if (!titleMatch) return null;
            
            const title = titleMatch[1].replace(/\.$/, '');
            const authors = text.substring(0, text.indexOf('"')).trim().replace(/\.$/, '');
            
            // Get everything after the closing quote
            let afterTitle = text.substring(text.indexOf(titleMatch[0]) + titleMatch[0].length).trim();
            
            // Remove leading period if present
            afterTitle = afterTitle.replace(/^\.\s*/, '');
            
            // Pattern 1: Journal Volume.Issue (Year): Pages.
            // Example: Quantitative imaging in medicine and surgery 14.12 (2024): 9620.
            const mlaPatternWithPages = /^([A-Za-z][^0-9]*?)\s+(\d+)(?:\.(\d+))?\s*\((\d{4})\):\s*(\d+(?:[â€“\-]\d+)?)\s*\.?\s*$/;
            let match = afterTitle.match(mlaPatternWithPages);
            
            if (match) {
                const volume = match[2];
                const issue = match[3];
                const volStr = issue ? `${volume}(${issue})` : volume;
                const source = match[1].trim().replace(/\.$/, '');
                
                return {
                    authors,
                    title,
                    source: source,
                    vol: volStr,
                    year: match[4],
                    pages: match[5],
                    type: "J"
                };
            }
            
            // Pattern 2: Journal Volume (Year). - No pages, common for conference proceedings
            // Example: Advances in neural information processing systems 25 (2012).
            const mlaPatternNoPages = /^([A-Za-z].*?)\s+(\d+)\s*\((\d{4})\)\s*\.?\s*$/;
            match = afterTitle.match(mlaPatternNoPages);
            
            if (match) {
                const source = match[1].trim().replace(/\.$/, '');
                
                return {
                    authors,
                    title,
                    source: source,
                    vol: match[2],
                    year: match[3],
                    pages: "",
                    type: "J"
                };
            }
            
            // Pattern 3: Just Journal (Year) - No volume, no pages
            // Example: Some Journal Name (2024).
            const mlaPatternSimple = /^([A-Za-z][^()]+?)\s*\((\d{4})\)\s*\.?\s*$/;
            match = afterTitle.match(mlaPatternSimple);
            
            if (match) {
                let source = match[1].trim().replace(/\.$/, '');
                let vol = "";
                
                // Check if source ends with a number (volume)
                const trailingVolMatch = source.match(/^(.+?)\s+(\d+)\s*$/);
                if (trailingVolMatch) {
                    source = trailingVolMatch[1].trim();
                    vol = trailingVolMatch[2];
                }
                
                return {
                    authors,
                    title,
                    source: source,
                    vol: vol,
                    year: match[2],
                    pages: "",
                    type: "J"
                };
            }
            
            return null;
        }

        function parseAPA_Conference(text) {
            const dateMatch = text.match(/\((\d{4})[^)]*\)\./);
            if (!dateMatch) return null;
            
            const year = dateMatch[1];
            const parts = text.split(dateMatch[0]);
            const authors = parts[0].trim();
            let rest = parts[1].trim(); 

            const inMarker = ". In ";
            const inIndex = rest.indexOf(inMarker);
            if (inIndex === -1) return null;

            const title = rest.substring(0, inIndex).trim();
            const sourceFull = rest.substring(inIndex + inMarker.length).trim();
            
            let pages = "";
            let sourceName = sourceFull;
            let pubInfo = "";
            
            const pagesMatch = sourceFull.match(/\(pp?\.?\s*([\d\-â€“]+)\)/);
            if (pagesMatch) {
                pages = pagesMatch[1].replace('â€“', '-');
                let pIndex = sourceFull.indexOf(pagesMatch[0]);
                sourceName = sourceFull.substring(0, pIndex).trim();
                pubInfo = sourceFull.substring(pIndex + pagesMatch[0].length).trim();
            } else {
                let lastDot = sourceFull.lastIndexOf('.');
                sourceName = sourceFull.substring(0, lastDot);
                pubInfo = sourceFull.substring(lastDot);
            }

            pubInfo = pubInfo.replace(/^\.\s*/, '').replace(/\.$/, '');
            let city = "", publisher = pubInfo;
            if (pubInfo.includes(':')) {
                let pp = pubInfo.split(':');
                city = pp[0].trim();
                publisher = pp.slice(1).join(':').trim();
            }

            return { authors, title, source: sourceName, year, pages, city, publisher, type: "C" };
        }

        function parseMLA_Book_Conf(text) {
            const yearRegex = /,\s*(\d{4})\.?$/;
            const yearMatch = text.match(yearRegex);
            if (!yearMatch || !text.includes('"')) return null;
            
            const year = yearMatch[1];
            const titleMatch = text.match(/"([^"]+)"/);
            const title = titleMatch[1];
            const authors = text.substring(0, text.indexOf('"')).trim().replace(/\.$/, '');
            
            let rest = text.substring(text.indexOf(titleMatch[0]) + titleMatch[0].length, text.lastIndexOf(yearMatch[0])).trim().replace(/^\.\s*/, '');
            
            let source = rest, city = "", publisher = "";
            if (rest.includes(':')) {
                let parts = rest.split(':');
                publisher = parts[1].trim();
                let prePub = parts[0].trim();
                let lastDot = prePub.lastIndexOf('.');
                if (lastDot !== -1) {
                    source = prePub.substring(0, lastDot).trim();
                    city = prePub.substring(lastDot + 1).trim();
                } else {
                    source = prePub;
                }
            }
            return { authors, title, source, year, city, publisher, type: source.match(/conference|proceeding/i) ? "C" : "M" };
        }

        // Parse APA Journal format: Authors (Year). Title. Journal, Volume(Issue), Pages.
        function parseAPA_Journal(text) {
            // Must have year in parentheses
            const yearMatch = text.match(/\((\d{4})\)\./);
            if (!yearMatch) return null;
            
            const year = yearMatch[1];
            const yearPos = text.indexOf(yearMatch[0]);
            
            const authors = text.substring(0, yearPos).trim();
            let rest = text.substring(yearPos + yearMatch[0].length).trim();
            
            // Pattern: Title. Journal, Volume(Issue), Pages.
            // We need to find: journal name, volume, issue (optional), pages
            // Look for pattern at the end: , Volume(Issue), Pages. or , Volume, Pages.
            
            // Try pattern with issue: , Vol(Issue), Pages
            let endPattern = /,\s*(\d+)\((\d+)\),\s*(\d+(?:[â€“\-]\d+)?)\s*\.?\s*$/;
            let endMatch = rest.match(endPattern);
            
            if (!endMatch) {
                // Try pattern without issue: , Vol, Pages
                endPattern = /,\s*(\d+),\s*(\d+(?:[â€“\-]\d+)?)\s*\.?\s*$/;
                endMatch = rest.match(endPattern);
                
                if (endMatch) {
                    // No issue number
                    const beforeEnd = rest.substring(0, rest.indexOf(endMatch[0]));
                    const lastDotIndex = beforeEnd.lastIndexOf('. ');
                    
                    let title, source;
                    if (lastDotIndex !== -1) {
                        title = beforeEnd.substring(0, lastDotIndex).trim();
                        source = beforeEnd.substring(lastDotIndex + 2).trim();
                    } else {
                        return null;
                    }
                    
                    return {
                        authors,
                        title: title.replace(/\.$/, ''),
                        source: source.replace(/\.$/, '').replace(/,\s*$/, ''),
                        year,
                        vol: endMatch[1],
                        pages: endMatch[2].replace('â€“', '-'),
                        type: "J"
                    };
                }
                return null;
            }
            
            // Found pattern with issue
            const beforeEnd = rest.substring(0, rest.indexOf(endMatch[0]));
            const lastDotIndex = beforeEnd.lastIndexOf('. ');
            
            let title, source;
            if (lastDotIndex !== -1) {
                title = beforeEnd.substring(0, lastDotIndex).trim();
                source = beforeEnd.substring(lastDotIndex + 2).trim();
            } else {
                return null;
            }
            
            return {
                authors,
                title: title.replace(/\.$/, ''),
                source: source.replace(/\.$/, '').replace(/,\s*$/, ''),
                year,
                vol: `${endMatch[1]}(${endMatch[2]})`,
                pages: endMatch[3].replace('â€“', '-'),
                type: "J"
            };
        }

        function parseStandardJournal(text) {
            // Generic fallback parser
            if (!text.match(/\d+\s*\(\d+\)/) && !text.match(/\d+\.\d+/) && !text.match(/\d+,\s*\d+/)) return null; 
            
            let yearMatch = text.match(/\((19|20)\d{2}\)/);
            if (!yearMatch) yearMatch = text.match(/(19|20)\d{2}/);
            if (!yearMatch) return null;
            
            const year = yearMatch[0].replace(/[\(\)]/g,'');
            let parts = text.split(yearMatch[0]);
            if(parts.length < 2) return null;

            let title = "", authors = "", source = "";
            if (text.includes('"')) {
                let tm = text.match(/"([^"]+)"/);
                title = tm[1];
                authors = text.split('"')[0].trim().replace(/\.$/, '');
                source = text.split('"')[2].split(yearMatch[0])[0].trim();
            } else {
                if (text.indexOf('(' + year + ')') > -1) {
                   authors = parts[0].trim();
                   let rest = parts[1].trim();
                   if (rest.startsWith('.')) rest = rest.substring(1).trim();
                   let firstDot = rest.indexOf('. ');
                   if (firstDot > -1) {
                       title = rest.substring(0, firstDot);
                       source = rest.substring(firstDot+2);
                   }
                }
            }
            
            let endPart = text.substring(text.lastIndexOf(year) + 4);
            let vol = "", pages = "";
            let volMatch = endPart.match(/(\d+(\(\d+\))?)/);
            if (volMatch) vol = volMatch[0];
            let pageMatch = endPart.match(/:?\.?\s*([\d\-â€“]+)$/);
            if (pageMatch) pages = pageMatch[1].replace('â€“', '-');
            
            return { authors, title, source: source.replace(/^[.,\s]+|[.,\s]+$/g, ''), year, vol, pages, type: "J" };
        }

        function validateParsedData(data) {
            if (!data.authors || !data.authors.trim()) {
                return "ç¼ºå°‘ä½œè€…ä¿¡æ¯";
            }
            if (!data.title || !data.title.trim()) {
                return "ç¼ºå°‘æ ‡é¢˜ä¿¡æ¯";
            }
            if (!data.year || !data.year.trim()) {
                return "ç¼ºå°‘å¹´ä»½ä¿¡æ¯";
            }
            // Pages are optional for conferences (some just have paper ID/number)
            return null;
        }

        function formatGBT(data, idx, lang = 'en') {
            let authors = formatAuthors(data.authors, lang);
            let title = data.title.replace(/\.$/, '');
            let source = data.source.replace(/^[.,\s]+|[.,\s]+$/g, '');
            source = source.split(' ').map(w => w.length > 3 ? w.charAt(0).toUpperCase() + w.slice(1) : w).join(' ');

            let plain = "", html = "";
            if (data.type === 'C') {
                // Conference proceedings format
                let pub = data.city ? `${data.city}: ${data.publisher}` : data.publisher;
                let pageStr = data.pages ? `: ${data.pages}` : "";
                plain = `[${idx}] ${authors}. ${title}[C]//${source}. ${pub}, ${data.year}${pageStr}.`;
                html = `<div class="reference-item p-3 rounded-lg">[${idx}] ${authors}. ${title}[C]//<span class="journal-name">${source}</span>. ${pub}, ${data.year}${pageStr}.</div>`;
            } else if (data.type === 'M') {
                // Book format
                let pub = data.city ? `${data.city}: ${data.publisher}` : data.publisher;
                let pageStr = data.pages ? `: ${data.pages}` : "";
                plain = `[${idx}] ${authors}. ${title}[M]//${source}. ${pub}, ${data.year}${pageStr}.`;
                html = `<div class="reference-item p-3 rounded-lg">[${idx}] ${authors}. ${title}[M]//<span class="journal-name">${source}</span>. ${pub}, ${data.year}${pageStr}.</div>`;
            } else {
                // Journal article format
                let volStr = data.vol ? `, ${data.vol}` : "";
                let pageStr = data.pages ? `: ${data.pages}` : "";
                plain = `[${idx}] ${authors}. ${title}[J]. ${source}, ${data.year}${volStr}${pageStr}.`;
                html = `<div class="reference-item p-3 rounded-lg">[${idx}] ${authors}. ${title}[J]. <span class="journal-name">${source}</span>, ${data.year}${volStr}${pageStr}.</div>`;
            }
            return { plain, html };
        }

        function formatBibTeX(data, idx) {
            let firstAuthor = data.authors.split(/[,\s]/)[0] || "auth";
            let key = firstAuthor.replace(/[^a-z]/gi,'').toLowerCase() + data.year;
            let type = data.type === 'M' ? 'book' : (data.type === 'C' ? 'inproceedings' : 'article');
            let bib = `@${type}{${key}${idx},\n`;
            bib += `  author = {${formatAuthorsForBibtex(data.authors)}},\n`;
            bib += `  title = {${data.title.replace(/\.$/, '')}},\n`;
            if (type === 'article') {
                bib += `  journal = {${data.source}},\n`;
                if(data.vol) {
                    // Parse volume and issue from vol string like "14(12)"
                    const volIssueMatch = data.vol.match(/(\d+)\((\d+)\)/);
                    if (volIssueMatch) {
                        bib += `  volume = {${volIssueMatch[1]}},\n`;
                        bib += `  number = {${volIssueMatch[2]}},\n`;
                    } else {
                        bib += `  volume = {${data.vol}},\n`;
                    }
                }
            } else if (type === 'inproceedings') {
                bib += `  booktitle = {${data.source}},\n`;
                if(data.vol) bib += `  volume = {${data.vol}},\n`;
                if(data.publisher) bib += `  publisher = {${data.publisher}},\n`;
                if(data.city) bib += `  address = {${data.city}},\n`;
            } else {
                // book
                bib += `  booktitle = {${data.source}},\n`;
                if(data.publisher) bib += `  publisher = {${data.publisher}},\n`;
                if(data.city) bib += `  address = {${data.city}},\n`;
            }
            if(data.pages) bib += `  pages = {${data.pages}},\n`;
            bib += `  year = {${data.year}}\n}`;
            return bib;
        }

        function convertRaw() {
            const input = document.getElementById('input-raw').value;
            const lines = input.split('\n').filter(l => l.trim());
            let html = [], plain = [], bib = [];

            lines.forEach((line, i) => {
                let clean = line.replace(/^(\[\d+\]|\d+\.)\s*/, '').trim();
                const lang = detectLanguage(clean);

                // Try parsers in order of specificity
                let parsed = null;
                
                // First try MLA Journal (has quotes and Volume.Issue pattern)
                parsed = parseMLA_Journal(clean);
                
                // Then try APA Journal (has year in parentheses at start, comma-separated vol/pages at end)
                if (!parsed) parsed = parseAPA_Journal(clean);
                
                // Then try APA Conference
                if (!parsed) parsed = parseAPA_Conference(clean);
                
                // Then try MLA Book/Conference
                if (!parsed) parsed = parseMLA_Book_Conf(clean);
                
                // Finally try generic parser
                if (!parsed) parsed = parseStandardJournal(clean);

                if (parsed) {
                    const validationError = validateParsedData(parsed);
                    if (validationError) {
                        html.push(`<div class="text-red-600 bg-red-50 p-3 rounded-lg border border-red-200 flex items-center gap-2"><svg class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg><span>è¡Œ ${i+1}: ${validationError}</span></div>`);
                        plain.push(`[ERROR] Line ${i+1}: ${validationError}`);
                        return;
                    }
                    let res = formatGBT(parsed, i+1, lang);
                    html.push(res.html);
                    plain.push(res.plain);
                    bib.push(formatBibTeX(parsed, i+1));
                } else {
                    html.push(`<div class="text-amber-700 bg-amber-50 p-3 rounded-lg border border-amber-200 flex items-center gap-2"><svg class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg><span>è¡Œ ${i+1}: æ ¼å¼æœªè¯†åˆ«ï¼Œè¯·æ£€æŸ¥è¾“å…¥æ ¼å¼</span></div>`);
                    plain.push(`[ERROR] Line ${i+1}: Format not recognized`);
                }
            });

            document.getElementById('output-content-html').innerHTML = html.join('');
            document.getElementById('output-content-text').value = plain.join('\n');
            document.getElementById('output-bibtex').innerText = bib.join('\n\n');
            document.getElementById('output-container').classList.remove('hidden');
            
            // Scroll to output
            document.getElementById('output-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function convertManual() {
            const d = {
                authors: document.getElementById('man-author').value,
                title: document.getElementById('man-title').value,
                source: document.getElementById('man-source').value,
                year: document.getElementById('man-year').value,
                vol: document.getElementById('man-vol').value,
                pages: document.getElementById('man-pages').value,
                type: document.getElementById('man-type').value,
                city: document.getElementById('man-city').value,
                publisher: document.getElementById('man-publisher').value
            };

            const validationError = validateParsedData(d);
            if (validationError) {
                document.getElementById('output-content-html').innerHTML = `<div class="text-red-600 bg-red-50 p-3 rounded-lg border border-red-200 flex items-center gap-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg><span>${validationError}</span></div>`;
                document.getElementById('output-content-text').value = `[ERROR] ${validationError}`;
                document.getElementById('output-bibtex').innerText = '';
                document.getElementById('output-container').classList.remove('hidden');
                return;
            }

            const lang = detectLanguage(d.authors + d.title + d.source);

            let res = formatGBT(d, 1, lang);
            document.getElementById('output-content-html').innerHTML = res.html;
            document.getElementById('output-content-text').value = res.plain;
            document.getElementById('output-bibtex').innerText = formatBibTeX(d, 1);
            document.getElementById('output-container').classList.remove('hidden');
        }

        function copyOutput(id) {
            let t = id.includes('text') ? document.getElementById(id).value : document.getElementById(id).innerText;
            navigator.clipboard.writeText(t).then(() => showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'));
        }

        function copyBibtex() {
            let t = document.getElementById('output-bibtex').innerText;
            navigator.clipboard.writeText(t).then(() => showToast('BibTeX å·²å¤åˆ¶'));
        }

        function loadDemo() {
            document.getElementById('input-raw').value = `Teng, Zixuan, et al. "A literature review of artificial intelligence (AI) for medical image segmentation: from AI and explainable AI to trustworthy AI." Quantitative imaging in medicine and surgery 14.12 (2024): 9620.
Teng, Z., Li, L., Xin, Z., Xiang, D., Huang, J., Zhou, H., ... & Chen, X. (2024). A literature review of artificial intelligence (AI) for medical image segmentation: from AI and explainable AI to trustworthy AI. Quantitative imaging in medicine and surgery, 14(12), 9620.
Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E. Hinton. "Imagenet classification with deep convolutional neural networks." Advances in neural information processing systems 25 (2012).
Acebes, C., Moustafa, A. H., Camara, O., & Galdran, A. (2024, October). The centerline-cross entropy loss for vessel-like structure segmentation: Better topology consistency without sacrificing accuracy. In International Conference on Medical Image Computing and Computer-Assisted Intervention (pp. 710-720). Cham: Springer Nature Switzerland.`;
            document.getElementById('line-count').textContent = '4';
        }
    </script>
</body>
</html>
