<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GB/T 7714-2015 参考文献生成器</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            background-color: #f3f4f6;
        }
        .reference-output {
            font-family: "Times New Roman", serif;
            line-height: 1.6;
        }
        /* Style for Journal Names - Normal style as requested */
        .journal-name {
            font-style: normal;
        }
        [class*="lamrena"], 
        [id*="lamrena"],
        [style*="lamrena"],
        .credits,
        .watermark,
        .built-with,
        .footer-watermark,
        .fixed[style*="bottom"],
        .absolute[style*="bottom"],
        .powered-by,
        .advertisement,
        .sponsor {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            height: 0 !important;
            width: 0 !important;
            pointer-events: none !important;
            position: absolute !important;
            left: -9999px !important;
            top: -9999px !important;
        }
        
        
        iframe[src*="lamrena"],
        iframe[title*="lamrena"] {
            display: none !important;
        }
    </style>
    
    
    <script>
    
    (function() {
        
        function removeWatermarks() {
            
            const walker = document.createTreeWalker(
                document.body,
                NodeFilter.SHOW_ALL,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                if (node.nodeType === 1) {
                    const text = node.textContent || '';
                    const className = node.className || '';
                    const id = node.id || '';
                    const style = node.style.cssText || '';
                    
                    
                    if (text.toLowerCase().includes('lamrena') ||
                        text.toLowerCase().includes('built with') ||
                        className.toLowerCase().includes('lamrena') ||
                        id.toLowerCase().includes('lamrena') ||
                        style.toLowerCase().includes('lamrena') ||
                        text.toLowerCase().includes('powered by')) {
                        node.remove();
                    }
                }
            }
            
            
            const fixedElements = document.querySelectorAll('*');
            fixedElements.forEach(el => {
                const style = window.getComputedStyle(el);
                if (style.position === 'fixed' || style.position === 'absolute') {
                    const rect = el.getBoundingClientRect();
                    
                    if (rect.bottom > window.innerHeight - 100 && 
                        rect.right > window.innerWidth - 200) {
                        if (el.textContent && el.textContent.length < 50) {
                            el.remove();
                        }
                    }
                }
            });
        }
        
        
        removeWatermarks();
        
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', removeWatermarks);
        } else {
            removeWatermarks();
        }
        
        
        const observer = new MutationObserver((mutations) => {
            let found = false;
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === 1) {
                        const text = node.textContent || '';
                        if (text.toLowerCase().includes('lamrena') || 
                            text.toLowerCase().includes('built with')) {
                            node.remove();
                            found = true;
                        }
                        
                        
                        const childNodes = node.querySelectorAll ? node.querySelectorAll('*') : [];
                        childNodes.forEach(child => {
                            if (child.textContent && 
                                child.textContent.toLowerCase().includes('lamrena')) {
                                child.remove();
                                found = true;
                            }
                        });
                    }
                });
            });
            
            if (found) {
                removeWatermarks(); 
            }
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: false,
            characterData: false
        });
        
        
        const cleanupInterval = setInterval(removeWatermarks, 1000);
        
        
        setTimeout(() => {
            clearInterval(cleanupInterval);
            observer.disconnect();
        }, 30000);
        
        
        document.addEventListener('click', removeWatermarks, true);
        document.addEventListener('scroll', removeWatermarks, true);
        
        
        window.alert = function() {};
        console.log = function() {};
        
    })();
    </script>
</head>
<body class="min-h-screen p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-lg overflow-hidden">
        <!-- Header -->
        <header class="bg-indigo-700 p-6 text-white">
            <h1 class="text-2xl font-bold">GB/T 7714-2015 参考文献生成器</h1>
            <p class="text-indigo-100 mt-2">智能识别英文引用格式 (APA, MLA, IEEE, etc.) 并转换为国标格式</p>
        </header>

        <!-- Main Content -->
        <main class="p-6 space-y-8">
            
            <!-- Mode Toggle -->
            <div class="flex border-b border-gray-200">
                <button id="tab-auto" class="px-6 py-3 text-indigo-700 border-b-2 border-indigo-700 font-medium focus:outline-none" onclick="switchTab('auto')">
                    智能转换 (Auto)
                </button>
                <button id="tab-manual" class="px-6 py-3 text-gray-500 hover:text-gray-700 font-medium focus:outline-none" onclick="switchTab('manual')">
                    手动录入 (Manual)
                </button>
            </div>

            <!-- Auto Convert Section -->
            <div id="section-auto" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">输入英文参考文献 (每行一条):</label>
                    <textarea id="input-raw" rows="8" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition" placeholder="粘贴参考文献...&#10;例如: Quinn, Laura, et al. &quot;Interobserver variability studies.&quot; The British Journal of Radiology 96.1148 (2023): 20220972."></textarea>
                    <p class="text-xs text-gray-500 mt-1">支持 APA, MLA, Chicago, Vancouver, IEEE 以及常见的期刊直接复制格式。</p>
                </div>
                <div class="flex gap-3">
                    <button onclick="convertRaw()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-6 rounded-lg transition shadow-md">
                        转换格式
                    </button>
                    <button onclick="loadDemo()" class="bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 font-medium py-2 px-6 rounded-lg transition shadow-sm">
                        填入示例
                    </button>
                </div>
            </div>

            <!-- Manual Input Section (Hidden by default) -->
            <div id="section-manual" class="space-y-4 hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700">文献类型</label>
                        <select id="man-type" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                            <option value="J">期刊文章 [J]</option>
                            <option value="M">专著/书籍 [M]</option>
                            <option value="D">学位论文 [D]</option>
                            <option value="C">会议论文 [C]</option>
                            <option value="R">报告 [R]</option>
                        </select>
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700">作者 (Author)</label>
                        <input type="text" id="man-author" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="Smith, John A.">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700">题名 (Title)</label>
                        <input type="text" id="man-title" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="Title of the work">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700">刊名/出版者 (Journal/Publisher)</label>
                        <input type="text" id="man-source" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="Journal Name">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">年份 (Year)</label>
                        <input type="text" id="man-year" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="2023">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">卷(期) (Vol(Issue))</label>
                        <input type="text" id="man-vol" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="12(3)">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">页码 (Pages)</label>
                        <input type="text" id="man-pages" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="100-105">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">出版地 (City) (书籍必填)</label>
                        <input type="text" id="man-city" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" placeholder="New York">
                    </div>
                </div>
                <button onclick="convertManual()" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-6 rounded-lg transition shadow-md mt-4">
                    生成引用
                </button>
            </div>

            <!-- Output Section -->
            <div id="output-container" class="bg-gray-50 rounded-lg p-4 border border-gray-200 hidden space-y-6">
                
                <!-- GB/T Output -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold text-gray-800">转换结果 (GB/T 7714-2015)</h3>
                        <div class="flex gap-2">
                            <button onclick="copyOutput('output-content-text')" class="text-sm text-indigo-600 hover:text-indigo-800 font-medium flex items-center gap-1 bg-white px-2 py-1 rounded border border-indigo-200">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"></path></svg>
                                复制文本
                            </button>
                        </div>
                    </div>
                    <!-- Visual Display -->
                    <div id="output-content-html" class="reference-output text-gray-800 space-y-3 border-b pb-4 border-gray-200 pl-2"></div>
                    <!-- Hidden Text Area for Copying (Plain Text) -->
                    <textarea id="output-content-text" class="hidden"></textarea>
                </div>

                <!-- BibTeX Output -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold text-gray-800">BibTeX</h3>
                        <button onclick="copyOutput('output-bibtex')" class="text-sm text-indigo-600 hover:text-indigo-800 font-medium flex items-center gap-1 bg-white px-2 py-1 rounded border border-indigo-200">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"></path></svg>
                            复制 BibTeX
                        </button>
                    </div>
                    <div id="output-bibtex" class="font-mono text-sm text-gray-700 bg-gray-100 p-3 rounded overflow-x-auto whitespace-pre border border-gray-200"></div>
                </div>

            </div>
            
            <!-- Information / Guide -->
            <div class="bg-indigo-50 p-4 rounded-lg text-sm text-indigo-900">
                <p class="font-bold mb-1">转换说明：</p>
                <ul class="list-disc list-inside space-y-1 opacity-90">
                    <li>GB/T 7714 格式：作者姓名大写 (SMITH J)，多于3位保留前3位加 ", et al."。</li>
                    <li>BibTeX 格式：作者格式为 "Lastname, Firstname"，多位作者用 " and " 连接。</li>
                    <li>BibTeX 格式：Volume 和 Number 会自动分离。</li>
                    <li>若无法识别格式，将显示错误提示。</li>
                </ul>
            </div>

        </main>
        
        <footer class="bg-gray-100 p-4 text-center text-gray-500 text-xs">
            &copy; 2023 GB/T 7714 Generator.
        </footer>
    </div>

    <script>
        // Tab Switching Logic
        function switchTab(mode) {
            const tabAuto = document.getElementById('tab-auto');
            const tabManual = document.getElementById('tab-manual');
            const secAuto = document.getElementById('section-auto');
            const secManual = document.getElementById('section-manual');

            if (mode === 'auto') {
                tabAuto.classList.add('text-indigo-700', 'border-b-2', 'border-indigo-700');
                tabAuto.classList.remove('text-gray-500');
                tabManual.classList.remove('text-indigo-700', 'border-b-2', 'border-indigo-700');
                tabManual.classList.add('text-gray-500');
                
                secAuto.classList.remove('hidden');
                secManual.classList.add('hidden');
            } else {
                tabManual.classList.add('text-indigo-700', 'border-b-2', 'border-indigo-700');
                tabManual.classList.remove('text-gray-500');
                tabAuto.classList.remove('text-indigo-700', 'border-b-2', 'border-indigo-700');
                tabAuto.classList.add('text-gray-500');

                secManual.classList.remove('hidden');
                secAuto.classList.add('hidden');
            }
        }

        // --- Core Formatting Logic ---

        // Helper: Parse Author string into structure
        function parseAuthorsToObjects(authorStr) {
            if (!authorStr || authorStr === "UNKNOWN") return [];
            
            // 1. Pre-cleaning
            let cleanStr = authorStr
                .replace(/,?\s*(et al\.?|and others)/gi, '') // Remove et al for count
                .replace(/\s+(and|&)\s+/g, ', ') // Normalize separators
                .replace(/[\(\)\[\]"]/g, '') // Remove quotes/parens
                .trim();
            
            // Generic Smart Parser
            // Split by comma first to see segments
            let segments = cleanStr.split(/,\s*/).filter(s => s);
            
            let mergedAuthors = [];
            for (let i = 0; i < segments.length; i++) {
                let seg = segments[i];
                let isSurnameLike = /^[A-Z][a-z\-\']+$/.test(seg);
                
                // Heuristic: Merge "Surname, Name" if split by comma
                if (isSurnameLike && i + 1 < segments.length) {
                    let next = segments[i+1];
                    // If next element is short (Initials) or simple name, and not a Year/Digit
                    if (!next.includes(',') && !/^\d/.test(next)) {
                        mergedAuthors.push({ surname: seg, name: next });
                        i++; // Skip next
                        continue;
                    }
                }
                
                // Else, treat segment as full name "First Last" or "Last FM"
                if (seg.includes(' ')) {
                    let parts = seg.split(/\s+/);
                    let surname = parts[parts.length - 1];
                    let name = parts.slice(0, parts.length - 1).join(' ');
                    
                    // Check for "Smith J" vs "John Smith"
                    if (parts.length === 2 && parts[1].replace('.','').length === 1 && parts[0].length > 1) {
                         // "Smith J"
                         mergedAuthors.push({ surname: parts[0], name: parts[1] });
                    } else {
                         // "John Smith"
                         mergedAuthors.push({ surname: surname, name: name });
                    }
                } else {
                    mergedAuthors.push({ surname: seg, name: "" });
                }
            }
            return mergedAuthors;
        }

        // Format to GB/T: SURNAME Initials (e.g., QUINN L)
        function formatAuthors(authorStr) {
            let parsed = parseAuthorsToObjects(authorStr);
            let formatted = parsed.map(a => {
                let s = a.surname.toUpperCase();
                let n = "";
                if (a.name) {
                    n = a.name.split(/[\s\.\-]+/).map(p => p.charAt(0).toUpperCase()).join(' '); // No dots
                }
                return (s + " " + n).trim();
            });

            if (formatted.length > 3) {
                return formatted.slice(0, 3).join(', ') + ", et al";
            }
            return formatted.join(', ');
        }

        // --- Improved Parsers ---

        function parseNewStandard(text) {
            // Pattern: Author. "Title." Source Vol.Issue (Year): Pages.
            
            if (!text.includes('"')) return null;
            
            const titleMatch = text.match(/"([^"]+)"/);
            if (!titleMatch) return null;
            
            const title = titleMatch[1];
            const authorsPart = text.substring(0, text.indexOf(titleMatch[0])).trim().replace(/,$/, '').replace(/\.$/, '');
            let rest = text.substring(text.indexOf(titleMatch[0]) + titleMatch[0].length).trim().replace(/^\.\s*/, '');
            
            // Find Year in parens: (2023)
            const yearMatch = rest.match(/\((19|20)\d{2}\)/);
            if (!yearMatch) return null;
            
            const year = yearMatch[0].replace(/[\(\)]/g, '');
            const yearIndex = rest.indexOf(yearMatch[0]);
            
            let sourcePart = rest.substring(0, yearIndex).trim();
            let pagesPart = rest.substring(yearIndex + yearMatch[0].length).trim();
            let pages = pagesPart.replace(/^[:\s]+/, '').replace(/\.$/, '');
            
            let vol = "";
            let source = "";
            
            // Chicago style: "Journal 96, no. 1148"
            if (sourcePart.includes("no.")) {
                let p = sourcePart.split("no.");
                let issue = p[1].trim();
                let vPart = p[0].trim();
                let vMatch = vPart.match(/(\d+)[,\s]*$/);
                if (vMatch) {
                    vol = `${vMatch[1]}(${issue})`;
                    source = vPart.substring(0, vMatch.index).trim().replace(/,$/, '');
                } else {
                    source = vPart; 
                    vol = issue;
                }
            } else {
                // "Journal 96.1148" or "Journal 96(1148)"
                let volMatch = sourcePart.match(/\s(\d+[\.\(\)\/\d]*)$/);
                if (volMatch) {
                    let rawVol = volMatch[1];
                    source = sourcePart.substring(0, volMatch.index).trim();
                    if (rawVol.includes('.') && !rawVol.includes('(')) {
                        let vp = rawVol.split('.');
                        if (vp.length === 2) vol = `${vp[0]}(${vp[1]})`;
                        else vol = rawVol;
                    } else {
                        vol = rawVol;
                    }
                } else {
                    source = sourcePart;
                }
            }
            
            return { authors: authorsPart, title, source, year, vol, pages, type: "J" };
        }

        function parseAPA_Expanded(text) {
            // APA: Authors (Year). Title. Journal, Vol(Issue), Pages.
            const yearRegex = /\((\d{4})\)/;
            const yearMatch = text.match(yearRegex);
            if (!yearMatch) return null;
            
            const year = yearMatch[1];
            const parts = text.split(yearMatch[0]);
            const authors = parts[0].trim().replace(/\.$/, '');
            let rest = parts[1].trim(); 
            
            if (rest.startsWith('.')) {
                rest = rest.substring(1).trim();
            }
            
            let firstDot = rest.indexOf('. ');
            if (firstDot === -1 && rest.endsWith('.')) firstDot = rest.length - 1;
            
            let title = "";
            let sourceRest = "";
            
            if (firstDot !== -1) {
                title = rest.substring(0, firstDot);
                sourceRest = rest.substring(firstDot + 1).trim();
            } else {
                title = rest;
            }
            
            let segments = sourceRest.split(/,\s*/).filter(s => s.trim());
            if (segments.length < 2) return null;
            
            let pages = segments[segments.length - 1].replace(/\.$/, '').replace(/^p+\.?/, '');
            let vol = "";
            let source = "";
            
            if (segments.length >= 3) {
                vol = segments[segments.length - 2];
                source = segments.slice(0, segments.length - 2).join(', ');
            } else {
                let s0 = segments[0];
                let vMatch = s0.match(/(\d+(\(\d+\))?)$/);
                if (vMatch) {
                    vol = vMatch[1];
                    source = s0.substring(0, vMatch.index).trim();
                } else {
                    source = s0;
                }
            }
            
            return { authors, title, source, year, vol, pages, type: "J" };
        }

        function parseHarvard_Specific(text) {
            // Authors, Year. Title. Journal, Vol(Issue), p.Pages.
            const dateMatch = text.match(/,?\s+(19|20)\d{2}\./);
            if (!dateMatch) return null;
            
            let year = dateMatch[0].replace(/[^\d]/g, '');
            let splitIdx = dateMatch.index;
            let authors = text.substring(0, splitIdx).trim();
            let rest = text.substring(splitIdx + dateMatch[0].length).trim();
            
            let dotIdx = rest.indexOf('. ');
            let title = "", sourceRest = "";
            
            if (dotIdx !== -1) {
                title = rest.substring(0, dotIdx);
                sourceRest = rest.substring(dotIdx + 1).trim();
            } else {
                return null;
            }
            
            let segments = sourceRest.split(/,\s*/);
            let pages = segments[segments.length - 1].replace(/\.$/, '').replace(/^p+\.?/, '');
            let vol = segments.length >= 2 ? segments[segments.length - 2] : "";
            let source = segments.slice(0, segments.length - 2).join(', ');
            
            return { authors, title, source, year, vol, pages, type: "J" };
        }
        
        function parseVancouver_Fixed(text) {
            // Authors. Title. Journal. Year Date;Vol(Issue):Pages.
            const tailRegex = /\.?\s*((19|20)\d{2})[^;]*;([0-9]+(\([^\)]+\))?):([a-zA-Z0-9]+)\.?$/;
            const match = text.match(tailRegex);
            if (!match) return null;
            
            let year = match[1];
            let vol = match[3];
            let pages = match[5];
            
            let head = text.substring(0, match.index).trim();
            let parts = head.split(/\.\s+/);
            if (parts.length < 3) parts = head.split('.'); // Fallback no spaces
            parts = parts.filter(p => p.trim());
            
            if (parts.length < 3) return null;
            
            let source = parts[parts.length - 1];
            let authors = parts[0];
            let title = parts.slice(1, parts.length - 1).join('. ');
            
            return { authors, title, source, year, vol, pages, type: "J" };
        }

        // --- Output Generation ---

        function formatJournalTitle(str) {
            if (!str) return "";
            if (str === str.toUpperCase() && str.length > 4) str = str.toLowerCase();
            
            const minor = ['a', 'an', 'the', 'and', 'but', 'or', 'for', 'nor', 'on', 'at', 'to', 'from', 'by', 'with', 'in', 'of'];
            
            return str.split(' ').map((word, index) => {
                let cleanVal = word.replace(/[^a-zA-Z]/g, '').toLowerCase();
                if (!cleanVal) return word;
                
                if (index > 0 && minor.includes(cleanVal)) {
                    return word.toLowerCase();
                }
                return word.charAt(0).toUpperCase() + word.slice(1);
            }).join(' ');
        }

        function formatAuthorsBibTeX(authorStr) {
             let parsed = parseAuthorsToObjects(authorStr);
             return parsed.map(a => {
                 let s = a.surname; 
                 let n = a.name;
                 return n ? `${s}, ${n}` : s;
             }).join(' and ');
        }

        function formatBibTeX(data, index) {
            // Generate Key
            let firstAuthor = (data.authors || "anon").split(/[, ]/)[0].replace(/[^a-zA-Z]/g, '').toLowerCase();
            let year = data.year || "0000";
            let bib = `@article{${firstAuthor}${year}ref${index},\n`;
            
            // Clean fields
            const clean = (s) => (s || "").replace(/&/g, '\\&');
            
            // Fix: BibTeX style authors
            bib += `  author = {${clean(formatAuthorsBibTeX(data.authors))}},\n`;
            
            // Fix: Title no trailing dot
            let title = (data.title || "").trim().replace(/\.$/, '');
            bib += `  title = {${clean(title)}},\n`;
            
            // Fix: Journal Title Case
            let source = formatJournalTitle((data.source || "").trim().replace(/,$/, ''));
            bib += `  journal = {${clean(source)}},\n`;
            
            bib += `  year = {${clean(data.year)}},\n`;
            
            // Fix: Volume/Number separation
            if (data.vol) {
                let v = data.vol;
                let n = "";
                // Logic to separate Issue from Volume
                // Check 12(3)
                let m = v.match(/^(.+)\((.+)\)$/);
                if (m) {
                    v = m[1];
                    n = m[2];
                } else if (v.includes('.') && !v.includes(' ')) {
                    // Check 12.3
                    let parts = v.split('.');
                    if (parts.length === 2) {
                        v = parts[0];
                        n = parts[1];
                    }
                }
                
                bib += `  volume = {${clean(v)}},\n`;
                if (n) bib += `  number = {${clean(n)}},\n`;
            }
            
            if (data.pages) bib += `  pages = {${clean(data.pages)}},\n`;
            bib += `}`;
            return bib;
        }

        function formatGBT(data, index) {
            let authors = formatAuthors(data.authors);
            // Fix: Title no trailing dot
            let title = (data.title || "").trim().replace(/\.$/, '');
            
            // Fix: Journal Title Case
            let source = formatJournalTitle((data.source || "").trim().replace(/,$/, ''));
            
            let year = data.year;
            let vol = data.vol;
            let pages = data.pages;
            
            // Plain text construction
            let plain = `[${index}] ${authors}. ${title}[J]. ${source}, ${year}, ${vol}: ${pages}.`;
            
            // HTML Version
            let htmlSource = `<span class="journal-name">${source}</span>`;
            let html = `[${index}] ${authors}. ${title}[J]. ${htmlSource}, ${year}, ${vol}: ${pages}.`;
            
            return { plain, html };
        }

        // --- Main Controller ---

        function convertRaw() {
            const input = document.getElementById('input-raw').value;
            if (!input.trim()) return;
            
            const lines = input.split('\n').filter(l => l.trim());
            let htmlResults = [];
            let plainResults = [];
            let bibResults = [];
            
            lines.forEach((line, idx) => {
                let cleanLine = line.replace(/^(\[\d+\]|\d+\.)\s*/, '').trim();
                
                // Try parsers in order of specificity
                let parsed = parseNewStandard(cleanLine); 
                if (!parsed) parsed = parseVancouver_Fixed(cleanLine);
                if (!parsed) parsed = parseHarvard_Specific(cleanLine);
                if (!parsed) parsed = parseAPA_Expanded(cleanLine);
                
                // Fallback: ERROR Handling
                if (!parsed) {
                    htmlResults.push(`<div class="mb-2 p-3 bg-red-50 text-red-700 border border-red-200 rounded flex items-start gap-2">
                        <svg class="w-5 h-5 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        <div>
                            <p class="font-medium">无法识别格式 (第 ${idx + 1} 行)</p>
                            <p class="text-sm opacity-80 mt-1">${line}</p>
                            <p class="text-xs mt-2 text-red-600">建议手动录入或检查格式是否完整。</p>
                        </div>
                    </div>`);
                    plainResults.push(`[ERROR] Line ${idx + 1}: Format not recognized.`);
                    bibResults.push(`% Error: Line ${idx + 1} format not recognized.`);
                } else {
                    let res = formatGBT(parsed, idx + 1);
                    htmlResults.push(`<div class="mb-2 p-2 hover:bg-gray-100 rounded transition">${res.html}</div>`);
                    plainResults.push(res.plain);
                    bibResults.push(formatBibTeX(parsed, idx + 1));
                }
            });
            
            document.getElementById('output-content-html').innerHTML = htmlResults.join('');
            document.getElementById('output-content-text').value = plainResults.join('\n');
            document.getElementById('output-bibtex').innerText = bibResults.join('\n\n');
            document.getElementById('output-container').classList.remove('hidden');
        }

        function convertManual() {
             const data = {
                authors: document.getElementById('man-author').value,
                title: document.getElementById('man-title').value,
                source: document.getElementById('man-source').value,
                year: document.getElementById('man-year').value,
                vol: document.getElementById('man-vol').value,
                pages: document.getElementById('man-pages').value,
                type: document.getElementById('man-type').value,
                city: document.getElementById('man-city').value,
                publisher: document.getElementById('man-source').value
            };
            
            let res = formatGBT(data, 1);
            if (data.type === 'M') {
                 // Custom M format
                 let authors = formatAuthors(data.authors);
                 // Strip dot from title
                 let title = (data.title || "").trim().replace(/\.$/, '');
                 let pub = `${data.city}: ${data.publisher}, ${data.year}: ${data.pages}.`;
                 res.html = `[1] ${authors}. ${title}[M]. ${pub}`;
                 res.plain = res.html;
            }
            
            document.getElementById('output-content-html').innerHTML = `<div class="p-2">${res.html}</div>`;
            document.getElementById('output-content-text').value = res.plain;
            document.getElementById('output-bibtex').innerText = formatBibTeX(data, 1);
            document.getElementById('output-container').classList.remove('hidden');
        }
        
        function copyOutput(id) {
            let content = "";
            if (id === 'output-content-text') {
                content = document.getElementById('output-content-text').value;
            } else {
                content = document.getElementById(id).innerText;
            }
            navigator.clipboard.writeText(content).then(() => alert("已复制！"));
        }

        function loadDemo() {
            const d = `Quinn, Laura, et al. "Interobserver variability studies in diagnostic imaging: a methodological systematic review." The British Journal of Radiology 96.1148 (2023): 20220972.
Quinn, L., Tryposkiadis, K., Deeks, J., De Vet, H. C., Mallett, S., Mokkink, L. B., ... & Sitch, A. (2023). Interobserver variability studies in diagnostic imaging: a methodological systematic review. The British Journal of Radiology, 96(1148), 20220972.
Quinn, Laura, Konstantinos Tryposkiadis, Jon Deeks, Henrica CW De Vet, Sue Mallett, Lidwine B. Mokkink, Yemisi Takwoingi, Sian Taylor-Phillips, and Alice Sitch. "Interobserver variability studies in diagnostic imaging: a methodological systematic review." The British Journal of Radiology 96, no. 1148 (2023): 20220972.
Quinn, L., Tryposkiadis, K., Deeks, J., De Vet, H.C., Mallett, S., Mokkink, L.B., Takwoingi, Y., Taylor-Phillips, S. and Sitch, A., 2023. Interobserver variability studies in diagnostic imaging: a methodological systematic review. The British Journal of Radiology, 96(1148), p.20220972.
Quinn L, Tryposkiadis K, Deeks J, De Vet HC, Mallett S, Mokkink LB, Takwoingi Y, Taylor-Phillips S, Sitch A. Interobserver variability studies in diagnostic imaging: a methodological systematic review. The British Journal of Radiology. 2023 Jul 1;96(1148):20220972.`;
            document.getElementById('input-raw').value = d;
        }
      window.addEventListener('load', function() {
            
            const textNodes = [];
            const walker = document.createTreeWalker(
                document.body,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                if (node.nodeValue && 
                    (node.nodeValue.toLowerCase().includes('lamrena') ||
                     node.nodeValue.toLowerCase().includes('built with'))) {
                    textNodes.push(node);
                }
            }
            
            textNodes.forEach(textNode => {
                textNode.parentNode.remove();
            });
        });
    </script>
</body>
</html>