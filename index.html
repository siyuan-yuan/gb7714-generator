<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GB/T 7714-2015 参考文献生成器 (全能版)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body { font-family: -apple-system, system-ui, sans-serif; background-color: #f3f4f6; }
        .reference-output { font-family: "Times New Roman", serif; line-height: 1.6; }
        .journal-name { font-style: normal; }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-lg overflow-hidden">
        <header class="bg-indigo-700 p-6 text-white">
            <h1 class="text-2xl font-bold">GB/T 7714-2015 参考文献生成器</h1>
            <p class="text-indigo-100 mt-2">支持 APA, MLA, IEEE 等多种期刊与会议格式</p>
        </header>

        <main class="p-6 space-y-8">
            <!-- Mode Toggle -->
            <div class="flex border-b border-gray-200">
                <button id="tab-auto" class="px-6 py-3 text-indigo-700 border-b-2 border-indigo-700 font-medium" onclick="switchTab('auto')">智能转换</button>
                <button id="tab-manual" class="px-6 py-3 text-gray-500 font-medium" onclick="switchTab('manual')">手动录入</button>
            </div>

            <!-- Auto Convert Section -->
            <div id="section-auto" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">输入参考文献 (每行一条):</label>
                    <textarea id="input-raw" rows="8" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" placeholder="粘贴参考文献..."></textarea>
                </div>
                <div class="flex gap-3">
                    <button onclick="convertRaw()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-6 rounded-lg shadow-md">转换格式</button>
                    <button onclick="loadDemo()" class="bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 font-medium py-2 px-6 rounded-lg">填入示例</button>
                </div>
            </div>

            <!-- Manual Input Section -->
            <div id="section-manual" class="space-y-4 hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700">文献类型</label>
                        <select id="man-type" class="block w-full border border-gray-300 rounded-md p-2">
                            <option value="J">期刊文章 [J]</option>
                            <option value="C">会议论文 [C]</option>
                            <option value="M">专著/书籍 [M]</option>
                        </select>
                    </div>
                    <div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700">作者</label><input type="text" id="man-author" class="block w-full border border-gray-300 rounded-md p-2"></div>
                    <div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700">题名</label><input type="text" id="man-title" class="block w-full border border-gray-300 rounded-md p-2"></div>
                    <div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700">来源(刊名/会议)</label><input type="text" id="man-source" class="block w-full border border-gray-300 rounded-md p-2"></div>
                    <div><label class="block text-sm font-medium text-gray-700">年份</label><input type="text" id="man-year" class="block w-full border border-gray-300 rounded-md p-2"></div>
                    <div><label class="block text-sm font-medium text-gray-700">卷(期)</label><input type="text" id="man-vol" class="block w-full border border-gray-300 rounded-md p-2"></div>
                    <div><label class="block text-sm font-medium text-gray-700">出版地 (书籍/会议)</label><input type="text" id="man-city" class="block w-full border border-gray-300 rounded-md p-2"></div>
                    <div><label class="block text-sm font-medium text-gray-700">出版社 (书籍/会议)</label><input type="text" id="man-publisher" class="block w-full border border-gray-300 rounded-md p-2"></div>
                    <div><label class="block text-sm font-medium text-gray-700">页码</label><input type="text" id="man-pages" class="block w-full border border-gray-300 rounded-md p-2"></div>
                </div>
                <button onclick="convertManual()" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-6 rounded-lg mt-4">生成引用</button>
            </div>

            <!-- Output Section -->
            <div id="output-container" class="bg-gray-50 rounded-lg p-4 border border-gray-200 hidden space-y-6">
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold text-gray-800">GB/T 7714-2015</h3>
                        <button onclick="copyOutput('output-content-text')" class="text-sm text-indigo-600 hover:text-indigo-800 font-medium bg-white px-2 py-1 rounded border border-indigo-200">复制文本</button>
                    </div>
                    <div id="output-content-html" class="reference-output text-gray-800 space-y-3 border-b pb-4 border-gray-200 pl-2"></div>
                    <textarea id="output-content-text" class="hidden"></textarea>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-800 mb-2">BibTeX</h3>
                    <div id="output-bibtex" class="font-mono text-sm text-gray-700 bg-gray-100 p-3 rounded overflow-x-auto whitespace-pre border border-gray-200"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        function switchTab(mode) {
            const auto = mode === 'auto';
            document.getElementById('section-auto').classList.toggle('hidden', !auto);
            document.getElementById('section-manual').classList.toggle('hidden', auto);
            document.getElementById('tab-auto').className = auto ? "px-6 py-3 text-indigo-700 border-b-2 border-indigo-700 font-medium" : "px-6 py-3 text-gray-500 font-medium";
            document.getElementById('tab-manual').className = !auto ? "px-6 py-3 text-indigo-700 border-b-2 border-indigo-700 font-medium" : "px-6 py-3 text-gray-500 font-medium";
        }

        // --- Core Parsing Logic ---

        function parseAuthorsToObjects(authorStr) {
            if (!authorStr) return [];
            const hasEtAl = /et al/i.test(authorStr);
            let cleanStr = authorStr
                .replace(/,?\s*(et al\.?|and others)/gi, '')
                .replace(/\s+(&|and)\s+/g, ', ') // Handle "&" in APA
                .replace(/[\(\)\[\]"]/g, '')
                .trim();
            
            let segments = cleanStr.split(/,\s*/).filter(s => s);
            let mergedAuthors = [];
            
            for (let i = 0; i < segments.length; i++) {
                let seg = segments[i];
                let isSurnameLike = /^[A-Z][a-z\-\']+$/.test(seg);
                if (isSurnameLike && i + 1 < segments.length && !segments[i+1].includes(',') && !/^\d/.test(segments[i+1])) {
                    mergedAuthors.push({ surname: seg, name: segments[i+1] });
                    i++; 
                } else if (seg.includes(' ')) {
                    let parts = seg.split(/\s+/);
                    mergedAuthors.push({ surname: parts[parts.length - 1], name: parts.slice(0, parts.length - 1).join(' ') });
                } else {
                    mergedAuthors.push({ surname: seg, name: "" });
                }
            }
            mergedAuthors.hasEtAl = hasEtAl;
            return mergedAuthors;
        }

        function formatAuthors(authorStr) {
            let parsed = parseAuthorsToObjects(authorStr);
            let formatted = parsed.map(a => {
                let s = a.surname.toUpperCase();
                let n = a.name ? a.name.split(/[\s\.\-]+/).map(p => p.charAt(0).toUpperCase()).join(' ') : "";
                return (s + " " + n).trim();
            });
            if (formatted.length > 3 || (parsed.hasEtAl && formatted.length >= 1)) {
                return formatted.slice(0, 3).join(', ') + ", et al";
            }
            return formatted.join(', ');
        }

        // --- Parser 1: APA Conference/Book Chapter (你的新输入格式) ---
        function parseAPA_Conference(text) {
            // Pattern: Authors (Year, Month). Title. In Source (pp. xx-xx). City: Publisher.
            // 1. Find Date: (2024) or (2024, October)
            const dateMatch = text.match(/\((\d{4})[^)]*\)\./);
            if (!dateMatch) return null;
            
            const year = dateMatch[1];
            const parts = text.split(dateMatch[0]);
            const authors = parts[0].trim();
            let rest = parts[1].trim(); 

            // 2. Find ". In " marker
            const inMarker = ". In ";
            const inIndex = rest.indexOf(inMarker);
            if (inIndex === -1) return null;

            const title = rest.substring(0, inIndex).trim();
            const sourceFull = rest.substring(inIndex + inMarker.length).trim();
            
            // 3. Extract Pages (pp. 710-720)
            let pages = "";
            let sourceName = sourceFull;
            let pubInfo = "";
            
            const pagesMatch = sourceFull.match(/\(pp?\.?\s*([\d\-]+)\)/);
            if (pagesMatch) {
                pages = pagesMatch[1];
                let pIndex = sourceFull.indexOf(pagesMatch[0]);
                sourceName = sourceFull.substring(0, pIndex).trim();
                pubInfo = sourceFull.substring(pIndex + pagesMatch[0].length).trim();
            } else {
                // Try to split by last dot if no pages found
                let lastDot = sourceFull.lastIndexOf('.');
                sourceName = sourceFull.substring(0, lastDot);
                pubInfo = sourceFull.substring(lastDot);
            }

            // 4. Extract City and Publisher from pubInfo (. Cham: Springer...)
            pubInfo = pubInfo.replace(/^\.\s*/, '').replace(/\.$/, '');
            let city = "", publisher = pubInfo;
            if (pubInfo.includes(':')) {
                let pp = pubInfo.split(':');
                city = pp[0].trim();
                publisher = pp.slice(1).join(':').trim();
            }

            return { authors, title, source: sourceName, year, pages, city, publisher, type: "C" };
        }

        // --- Parser 2: MLA Book/Conference ---
        function parseMLA_Book_Conf(text) {
            const yearRegex = /,\s*(\d{4})\.?$/;
            const yearMatch = text.match(yearRegex);
            if (!yearMatch || !text.includes('"')) return null; // Must have quotes for MLA title
            
            const year = yearMatch[1];
            const titleMatch = text.match(/"([^"]+)"/);
            const title = titleMatch[1];
            const authors = text.substring(0, text.indexOf('"')).trim().replace(/\.$/, '');
            
            let rest = text.substring(text.indexOf(titleMatch[0]) + titleMatch[0].length, text.lastIndexOf(yearMatch[0])).trim().replace(/^\.\s*/, '');
            
            let source = rest, city = "", publisher = "";
            if (rest.includes(':')) {
                let parts = rest.split(':');
                publisher = parts[1].trim();
                let prePub = parts[0].trim();
                let lastDot = prePub.lastIndexOf('.');
                if (lastDot !== -1) {
                    source = prePub.substring(0, lastDot).trim();
                    city = prePub.substring(lastDot + 1).trim();
                } else {
                    source = prePub; // Assume whole thing is source
                }
            }
            return { authors, title, source, year, city, publisher, type: source.match(/conference|proceeding/i) ? "C" : "M" };
        }

        // --- Parser 3: Standard Journal ---
        function parseStandardJournal(text) {
            // Check for Vol(Issue) or Vol.Issue pattern
            if (!text.match(/\d+\s*\(\d+\)/) && !text.match(/\d+\.\d+/)) return null; 
            
            // Basic extraction logic...
            let yearMatch = text.match(/\((19|20)\d{2}\)/);
            if (!yearMatch) yearMatch = text.match(/(19|20)\d{2}/); // relaxed
            if (!yearMatch) return null;
            
            const year = yearMatch[0].replace(/[\(\)]/g,'');
            let parts = text.split(yearMatch[0]);
            if(parts.length < 2) return null;

            // Simple heuristic for Author/Title split if quotes exist
            let title = "", authors = "", source = "";
            if (text.includes('"')) {
                let tm = text.match(/"([^"]+)"/);
                title = tm[1];
                authors = text.split('"')[0].trim().replace(/\.$/, '');
                source = text.split('"')[2].split(yearMatch[0])[0].trim();
            } else {
                // APA Style fallback: Author (Year). Title. Source
                if (text.indexOf('(' + year + ')') > -1) {
                   authors = parts[0].trim();
                   let rest = parts[1].trim(); // . Title. Source...
                   if (rest.startsWith('.')) rest = rest.substring(1).trim();
                   // Find first dot to split Title and Source
                   let firstDot = rest.indexOf('. ');
                   if (firstDot > -1) {
                       title = rest.substring(0, firstDot);
                       source = rest.substring(firstDot+2);
                   }
                }
            }
            
            // Extract pages/vol from the end
            let endPart = text.substring(text.lastIndexOf(year) + 4);
            let vol = "", pages = "";
            let volMatch = endPart.match(/(\d+(\(\d+\))?)/);
            if (volMatch) vol = volMatch[0];
            let pageMatch = endPart.match(/:?\.?\s*([\d\-]+)$/);
            if (pageMatch) pages = pageMatch[1];
            
            return { authors, title, source: source.replace(/^[.,\s]+|[.,\s]+$/g, ''), year, vol, pages, type: "J" };
        }

        // --- Output Generation ---
        function formatGBT(data, idx) {
            let authors = formatAuthors(data.authors);
            let title = data.title.replace(/\.$/, '');
            let source = data.source.replace(/^[.,\s]+|[.,\s]+$/g, '');
            // Capitalize Source
            source = source.split(' ').map(w => w.length > 3 ? w.charAt(0).toUpperCase() + w.slice(1) : w).join(' ');

            let plain = "", html = "";
            if (data.type === 'C' || data.type === 'M') {
                let pub = data.city ? `${data.city}: ${data.publisher}` : data.publisher;
                let pageStr = data.pages ? `: ${data.pages}` : "";
                // GB/T Format for C/M: Source. City: Publisher, Year: Pages.
                plain = `[${idx}] ${authors}. ${title}[${data.type}]. ${source}. ${pub}, ${data.year}${pageStr}.`;
                html = `[${idx}] ${authors}. ${title}[${data.type}]. <span class="journal-name">${source}</span>. ${pub}, ${data.year}${pageStr}.`;
            } else {
                let volStr = data.vol ? `, ${data.vol}` : "";
                let pageStr = data.pages ? `: ${data.pages}` : "";
                plain = `[${idx}] ${authors}. ${title}[J]. ${source}, ${data.year}${volStr}${pageStr}.`;
                html = `[${idx}] ${authors}. ${title}[J]. <span class="journal-name">${source}</span>, ${data.year}${volStr}${pageStr}.`;
            }
            return { plain, html };
        }

        function formatBibTeX(data, idx) {
            let key = (data.authors.split(/[, ]/)[0] || "auth").replace(/[^a-z]/gi,'').toLowerCase() + data.year;
            let type = data.type === 'M' ? 'book' : (data.type === 'C' ? 'inproceedings' : 'article');
            let bib = `@${type}{${key}${idx},\n`;
            bib += `  author = {${data.authors.replace(/&/g, 'and').replace(/et al\.?/gi, 'and others')}},\n`;
            bib += `  title = {${data.title}},\n`;
            if (type === 'article') {
                bib += `  journal = {${data.source}},\n`;
                if(data.vol) bib += `  volume = {${data.vol}},\n`;
            } else {
                bib += `  booktitle = {${data.source}},\n`;
                if(data.publisher) bib += `  publisher = {${data.publisher}},\n`;
                if(data.city) bib += `  address = {${data.city}},\n`;
            }
            if(data.pages) bib += `  pages = {${data.pages}},\n`;
            bib += `  year = {${data.year}}\n}`;
            return bib;
        }

        function convertRaw() {
            const input = document.getElementById('input-raw').value;
            const lines = input.split('\n').filter(l => l.trim());
            let html = [], plain = [], bib = [];

            lines.forEach((line, i) => {
                let clean = line.replace(/^(\[\d+\]|\d+\.)\s*/, '').trim();
                // 优先级: 1. APA会议 2. MLA会议/书 3. 期刊
                let parsed = parseAPA_Conference(clean);
                if (!parsed) parsed = parseMLA_Book_Conf(clean);
                if (!parsed) parsed = parseStandardJournal(clean);

                if (parsed) {
                    let res = formatGBT(parsed, i+1);
                    html.push(`<div class="p-2 hover:bg-gray-100 rounded">${res.html}</div>`);
                    plain.push(res.plain);
                    bib.push(formatBibTeX(parsed, i+1));
                } else {
                    html.push(`<div class="text-red-600 bg-red-50 p-2 rounded">[Error] 行 ${i+1} 格式未识别</div>`);
                    plain.push(`[ERROR] Line ${i+1}`);
                }
            });

            document.getElementById('output-content-html').innerHTML = html.join('');
            document.getElementById('output-content-text').value = plain.join('\n');
            document.getElementById('output-bibtex').innerText = bib.join('\n\n');
            document.getElementById('output-container').classList.remove('hidden');
        }
        
        function convertManual() {
            // Same manual logic as before...
            const d = {
                authors: document.getElementById('man-author').value,
                title: document.getElementById('man-title').value,
                source: document.getElementById('man-source').value,
                year: document.getElementById('man-year').value,
                vol: document.getElementById('man-vol').value,
                pages: document.getElementById('man-pages').value,
                type: document.getElementById('man-type').value,
                city: document.getElementById('man-city').value,
                publisher: document.getElementById('man-publisher').value
            };
            let res = formatGBT(d, 1);
            document.getElementById('output-content-html').innerHTML = res.html;
            document.getElementById('output-content-text').value = res.plain;
            document.getElementById('output-bibtex').innerText = formatBibTeX(d, 1);
            document.getElementById('output-container').classList.remove('hidden');
        }

        function copyOutput(id) {
            let t = id.includes('text') ? document.getElementById(id).value : document.getElementById(id).innerText;
            navigator.clipboard.writeText(t).then(()=>alert('已复制'));
        }

        function loadDemo() {
            document.getElementById('input-raw').value = `Acebes, C., Moustafa, A. H., Camara, O., & Galdran, A. (2024, October). The centerline-cross entropy loss for vessel-like structure segmentation: Better topology consistency without sacrificing accuracy. In International Conference on Medical Image Computing and Computer-Assisted Intervention (pp. 710-720). Cham: Springer Nature Switzerland.
Acebes, Cesar, et al. "The centerline-cross entropy loss for vessel-like structure segmentation." International Conference on Medical Image Computing and Computer-Assisted Intervention. Cham: Springer Nature Switzerland, 2024.`;
        }
    </script>
</body>
</html>