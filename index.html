<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GB/T 7714-2015 参考文献生成器 (修复版)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            background-color: #f3f4f6;
        }
        .reference-output {
            font-family: "Times New Roman", serif;
            line-height: 1.6;
        }
        .journal-name {
            font-style: normal; /* GB/T 7714 规定刊名不倾斜，若需倾斜可改为 italic */
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-lg overflow-hidden">
        <header class="bg-indigo-700 p-6 text-white">
            <h1 class="text-2xl font-bold">GB/T 7714-2015 参考文献生成器</h1>
            <p class="text-indigo-100 mt-2">支持期刊、会议论文、专著等多种英文格式转换</p>
        </header>

        <main class="p-6 space-y-8">
            <!-- Mode Toggle -->
            <div class="flex border-b border-gray-200">
                <button id="tab-auto" class="px-6 py-3 text-indigo-700 border-b-2 border-indigo-700 font-medium focus:outline-none" onclick="switchTab('auto')">
                    智能转换 (Auto)
                </button>
                <button id="tab-manual" class="px-6 py-3 text-gray-500 hover:text-gray-700 font-medium focus:outline-none" onclick="switchTab('manual')">
                    手动录入 (Manual)
                </button>
            </div>

            <!-- Auto Convert Section -->
            <div id="section-auto" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">输入英文参考文献 (每行一条):</label>
                    <textarea id="input-raw" rows="8" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition" placeholder="粘贴参考文献...&#10;支持 MLA, APA, Chicago, Vancouver, IEEE 等格式"></textarea>
                </div>
                <div class="flex gap-3">
                    <button onclick="convertRaw()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-6 rounded-lg transition shadow-md">
                        转换格式
                    </button>
                    <button onclick="loadDemo()" class="bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 font-medium py-2 px-6 rounded-lg transition shadow-sm">
                        填入示例
                    </button>
                </div>
            </div>

            <!-- Manual Input Section -->
            <div id="section-manual" class="space-y-4 hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700">文献类型</label>
                        <select id="man-type" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                            <option value="J">期刊文章 [J]</option>
                            <option value="C">会议论文 [C]</option>
                            <option value="M">专著/书籍 [M]</option>
                            <option value="D">学位论文 [D]</option>
                        </select>
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700">作者 (Author)</label>
                        <input type="text" id="man-author" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700">题名 (Title)</label>
                        <input type="text" id="man-title" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700">刊名/会议名 (Source)</label>
                        <input type="text" id="man-source" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">年份 (Year)</label>
                        <input type="text" id="man-year" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                    <!-- Journal Specific -->
                    <div class="journal-field">
                        <label class="block text-sm font-medium text-gray-700">卷(期) (Vol(Issue))</label>
                        <input type="text" id="man-vol" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                    <!-- Book/Conf Specific -->
                    <div class="book-field">
                        <label class="block text-sm font-medium text-gray-700">出版地 (City)</label>
                        <input type="text" id="man-city" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                    <div class="book-field">
                        <label class="block text-sm font-medium text-gray-700">出版社 (Publisher)</label>
                        <input type="text" id="man-publisher" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">页码 (Pages)</label>
                        <input type="text" id="man-pages" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2">
                    </div>
                </div>
                <button onclick="convertManual()" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-6 rounded-lg transition shadow-md mt-4">
                    生成引用
                </button>
            </div>

            <!-- Output Section -->
            <div id="output-container" class="bg-gray-50 rounded-lg p-4 border border-gray-200 hidden space-y-6">
                <!-- GB/T Output -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold text-gray-800">转换结果 (GB/T 7714-2015)</h3>
                        <button onclick="copyOutput('output-content-text')" class="text-sm text-indigo-600 hover:text-indigo-800 font-medium bg-white px-2 py-1 rounded border border-indigo-200">
                            复制文本
                        </button>
                    </div>
                    <div id="output-content-html" class="reference-output text-gray-800 space-y-3 border-b pb-4 border-gray-200 pl-2"></div>
                    <textarea id="output-content-text" class="hidden"></textarea>
                </div>

                <!-- BibTeX Output -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold text-gray-800">BibTeX</h3>
                        <button onclick="copyOutput('output-bibtex')" class="text-sm text-indigo-600 hover:text-indigo-800 font-medium bg-white px-2 py-1 rounded border border-indigo-200">
                            复制 BibTeX
                        </button>
                    </div>
                    <div id="output-bibtex" class="font-mono text-sm text-gray-700 bg-gray-100 p-3 rounded overflow-x-auto whitespace-pre border border-gray-200"></div>
                </div>
            </div>
        </main>
        
        <footer class="bg-gray-100 p-4 text-center text-gray-500 text-xs">
            &copy; 2024 GB/T 7714 Generator.
        </footer>
    </div>

    <script>
        // --- 1. Tab Switching ---
        function switchTab(mode) {
            const tabAuto = document.getElementById('tab-auto');
            const tabManual = document.getElementById('tab-manual');
            const secAuto = document.getElementById('section-auto');
            const secManual = document.getElementById('section-manual');

            if (mode === 'auto') {
                tabAuto.classList.add('text-indigo-700', 'border-b-2', 'border-indigo-700', 'border-indigo-700');
                tabAuto.classList.remove('text-gray-500');
                tabManual.classList.remove('text-indigo-700', 'border-b-2');
                tabManual.classList.add('text-gray-500');
                secAuto.classList.remove('hidden');
                secManual.classList.add('hidden');
            } else {
                tabManual.classList.add('text-indigo-700', 'border-b-2', 'border-indigo-700');
                tabManual.classList.remove('text-gray-500');
                tabAuto.classList.remove('text-indigo-700', 'border-b-2');
                tabAuto.classList.add('text-gray-500');
                secManual.classList.remove('hidden');
                secAuto.classList.add('hidden');
            }
        }

        // --- 2. Parsers (核心解析逻辑) ---

        // Helper: Parse Author string
        function parseAuthorsToObjects(authorStr) {
            if (!authorStr || authorStr === "UNKNOWN") return [];
            
            // Check for explicit "et al" in input to preserve it later if needed
            const hasEtAl = /et al/i.test(authorStr);
            
            let cleanStr = authorStr
                .replace(/,?\s*(et al\.?|and others)/gi, '')
                .replace(/\s+(and|&)\s+/g, ', ')
                .replace(/[\(\)\[\]"]/g, '')
                .trim();
            
            let segments = cleanStr.split(/,\s*/).filter(s => s);
            let mergedAuthors = [];
            
            for (let i = 0; i < segments.length; i++) {
                let seg = segments[i];
                let isSurnameLike = /^[A-Z][a-z\-\']+$/.test(seg);
                
                // Merge "Surname, Name"
                if (isSurnameLike && i + 1 < segments.length) {
                    let next = segments[i+1];
                    if (!next.includes(',') && !/^\d/.test(next)) {
                        mergedAuthors.push({ surname: seg, name: next });
                        i++; 
                        continue;
                    }
                }
                
                // "First Last"
                if (seg.includes(' ')) {
                    let parts = seg.split(/\s+/);
                    let surname = parts[parts.length - 1];
                    let name = parts.slice(0, parts.length - 1).join(' ');
                    mergedAuthors.push({ surname: surname, name: name });
                } else {
                    mergedAuthors.push({ surname: seg, name: "" });
                }
            }
            // Mark the list if original input had et al
            mergedAuthors.hasEtAl = hasEtAl;
            return mergedAuthors;
        }

        // Output Formatter for GB/T Authors
        function formatAuthors(authorStr) {
            let parsed = parseAuthorsToObjects(authorStr);
            let formatted = parsed.map(a => {
                let s = a.surname.toUpperCase();
                let n = "";
                if (a.name) {
                    n = a.name.split(/[\s\.\-]+/).map(p => p.charAt(0).toUpperCase()).join(' ');
                }
                return (s + " " + n).trim();
            });

            // GB/T Rule: >3 authors -> first 3 + et al.
            // OR if input explicitly had "et al" (like "Acebes, Cesar, et al.")
            if (formatted.length > 3 || (parsed.hasEtAl && formatted.length >= 1)) {
                // If only 1 author parsed but had et al, keep 1 + et al
                let limit = Math.min(formatted.length, 3);
                return formatted.slice(0, limit).join(', ') + ", et al";
            }
            return formatted.join(', ');
        }

        // --- Parser 1: MLA Book/Conference (针对你遇到的问题) ---
        function parseMLA_Book_Conf(text) {
            // Pattern: Authors. "Title." Source. Location: Publisher, Year.
            // Example: Acebes... "Title." Conference. Cham: Springer, 2024.

            // 1. Must end with Year or "Year."
            const yearRegex = /,\s*(\d{4})\.?$/;
            const yearMatch = text.match(yearRegex);
            if (!yearMatch) return null;
            
            const year = yearMatch[1];
            
            // 2. Must have title in quotes
            const titleMatch = text.match(/"([^"]+)"/);
            if (!titleMatch) return null;
            
            const title = titleMatch[1];
            const authors = text.substring(0, text.indexOf('"')).trim().replace(/\.$/, '');
            
            // 3. Middle part: Source, Location, Publisher
            // Get text between Title and Year
            let restIndex = text.indexOf(titleMatch[0]) + titleMatch[0].length;
            let rest = text.substring(restIndex, text.lastIndexOf(yearMatch[0])).trim();
            // rest usually: ". Conference Name. City: Publisher"
            
            rest = rest.replace(/^\.\s*/, ''); // remove leading dot
            
            let source = "", city = "", publisher = "";
            let type = "M"; // Default Monograph
            
            // Check for Location: Publisher syntax
            let colonIndex = rest.lastIndexOf(':');
            if (colonIndex !== -1) {
                publisher = rest.substring(colonIndex + 1).trim();
                let beforeColon = rest.substring(0, colonIndex).trim();
                
                // Try to split Source and City by last dot
                let lastDot = beforeColon.lastIndexOf('.');
                if (lastDot !== -1) {
                    source = beforeColon.substring(0, lastDot).trim();
                    city = beforeColon.substring(lastDot + 1).trim();
                } else {
                    // Fallback: assume whole thing is source if no dot separating city
                    source = beforeColon;
                }
            } else {
                source = rest;
            }
            
            // Detect Conference Type
            if (/conference|proceeding|symposium|congress|meeting/i.test(source)) {
                type = "C";
            }

            return { authors, title, source, year, type, city, publisher, vol:"", pages:"" };
        }

        // --- Parser 2: Standard Journal Format ---
        function parseNewStandard(text) {
            if (!text.includes('"')) return null;
            const titleMatch = text.match(/"([^"]+)"/);
            if (!titleMatch) return null;
            const title = titleMatch[1];
            const authors = text.substring(0, text.indexOf(titleMatch[0])).trim().replace(/,$/, '').replace(/\.$/, '');
            let rest = text.substring(text.indexOf(titleMatch[0]) + titleMatch[0].length).trim().replace(/^\.\s*/, '');
            const yearMatch = rest.match(/\((19|20)\d{2}\)/);
            if (!yearMatch) return null;
            const year = yearMatch[0].replace(/[\(\)]/g, '');
            let sourcePart = rest.substring(0, rest.indexOf(yearMatch[0])).trim();
            let pages = rest.substring(rest.indexOf(yearMatch[0]) + yearMatch[0].length).trim().replace(/^[:\s]+/, '').replace(/\.$/, '');
            let vol = "";
            let source = sourcePart;
            
            let volMatch = sourcePart.match(/\s(\d+[\.\(\)\/\d]*)$/);
            if (volMatch) {
                vol = volMatch[1];
                source = sourcePart.substring(0, volMatch.index).trim();
            }
            return { authors, title, source, year, vol, pages, type: "J" };
        }

        // --- Parser 3: Vancouver / PubMed ---
        function parseVancouver(text) {
            const tailRegex = /\.?\s*((19|20)\d{2})[^;]*;([0-9]+(\([^\)]+\))?):([a-zA-Z0-9\-]+)\.?$/;
            const match = text.match(tailRegex);
            if (!match) return null;
            let year = match[1];
            let vol = match[3];
            let pages = match[5];
            let head = text.substring(0, match.index).trim();
            let parts = head.split(/\.\s+/).filter(p=>p);
            if (parts.length < 3) return null;
            let source = parts[parts.length - 1];
            let authors = parts[0];
            let title = parts.slice(1, parts.length - 1).join('. ');
            return { authors, title, source, year, vol, pages, type: "J" };
        }

        // --- Parser 4: APA / Harvard (Generic Fallback) ---
        function parseAPA(text) {
            const yearRegex = /\((\d{4})\)/;
            const yearMatch = text.match(yearRegex);
            if (!yearMatch) return null;
            const year = yearMatch[1];
            const parts = text.split(yearMatch[0]);
            const authors = parts[0].trim().replace(/\.$/, '');
            let rest = parts[1].trim().replace(/^\.\s*/, '');
            
            // Find Title (heuristic: text before first dot or italics)
            let titleEnd = rest.indexOf('. ');
            if (titleEnd === -1) titleEnd = rest.length;
            let title = rest.substring(0, titleEnd);
            let sourceRest = rest.substring(titleEnd + 1).trim();
            
            // Analyze Source
            let segments = sourceRest.split(/,\s*/);
            let pages = "", vol = "", source = sourceRest;
            
            if (segments.length >= 2) {
                let last = segments[segments.length-1];
                if (/\d+/.test(last)) {
                    pages = last.replace(/p+\.?/g, '');
                    source = segments.slice(0, segments.length-1).join(', ');
                }
            }
            
            // Try extract vol
            let vMatch = source.match(/,?\s*(\d+(\(\d+\))?)$/);
            if (vMatch) {
                vol = vMatch[1];
                source = source.substring(0, vMatch.index).trim();
            }
            
            return { authors, title, source, year, vol, pages, type: "J" };
        }

        // --- 3. Output Logic ---

        function formatTitleCase(str) {
            if (!str) return "";
            if (str === str.toUpperCase() && str.length > 4) str = str.toLowerCase();
            const minor = ['a','an','the','and','but','or','for','nor','on','at','to','from','by','with','in','of'];
            return str.split(' ').map((word, i) => {
                let clean = word.replace(/[^a-zA-Z]/g, '').toLowerCase();
                if (i > 0 && minor.includes(clean)) return word.toLowerCase();
                return word.charAt(0).toUpperCase() + word.slice(1);
            }).join(' ');
        }

        function formatGBTCitation(data, index) {
            let authors = formatAuthors(data.authors);
            let title = (data.title || "").trim().replace(/[.,]$/, '');
            let source = formatTitleCase((data.source || "").trim().replace(/,$/, ''));
            let year = data.year;
            
            let typeCode = data.type || "J";
            let plain = "", html = "";
            let htmlSource = `<span class="journal-name">${source}</span>`;

            // Logic for Book (M) or Conference (C)
            if (typeCode === 'M' || typeCode === 'C') {
                let pubInfo = "";
                if (data.city && data.publisher) {
                    pubInfo = `${data.city}: ${data.publisher}, ${year}`;
                } else if (data.publisher) {
                    pubInfo = `${data.publisher}, ${year}`;
                } else {
                    pubInfo = `${year}`; // Just year if nothing else
                }
                
                // Add pages if exist
                if (data.pages) pubInfo += `: ${data.pages}`;
                
                plain = `[${index}] ${authors}. ${title}[${typeCode}]. ${source}. ${pubInfo}.`;
                html = `[${index}] ${authors}. ${title}[${typeCode}]. ${htmlSource}. ${pubInfo}.`;
            } 
            // Logic for Journal (J)
            else {
                let volInfo = data.vol ? `, ${data.vol}` : "";
                let pageInfo = data.pages ? `: ${data.pages}` : "";
                
                plain = `[${index}] ${authors}. ${title}[J]. ${source}, ${year}${volInfo}${pageInfo}.`;
                html = `[${index}] ${authors}. ${title}[J]. ${htmlSource}, ${year}${volInfo}${pageInfo}.`;
            }
            
            return { plain, html };
        }

        function formatBibTeX(data, index) {
            let key = (data.authors || "ref").split(/[, ]/)[0].replace(/[^a-zA-Z]/g, '').toLowerCase() + (data.year || "");
            let type = data.type === 'M' ? 'book' : (data.type === 'C' ? 'inproceedings' : 'article');
            
            let bib = `@${type}{${key}${index},\n`;
            bib += `  author = {${data.authors.replace(/et al\.?/gi, 'and others')}},\n`;
            bib += `  title = {${data.title}},\n`;
            
            if (type === 'article') {
                bib += `  journal = {${data.source}},\n`;
                if(data.vol) bib += `  volume = {${data.vol}},\n`;
            } else {
                bib += `  booktitle = {${data.source}},\n`;
                if(data.publisher) bib += `  publisher = {${data.publisher}},\n`;
                if(data.city) bib += `  address = {${data.city}},\n`;
            }
            
            bib += `  year = {${data.year}}\n}`;
            return bib;
        }

        // --- 4. Main Functions ---

        function convertRaw() {
            const input = document.getElementById('input-raw').value;
            if (!input.trim()) return;
            
            const lines = input.split('\n').filter(l => l.trim());
            let htmlRes = [], plainRes = [], bibRes = [];
            
            lines.forEach((line, idx) => {
                let clean = line.replace(/^(\[\d+\]|\d+\.)\s*/, '').trim();
                
                // Try Parsers Priority
                let parsed = parseMLA_Book_Conf(clean); // New Parser First
                if (!parsed) parsed = parseNewStandard(clean);
                if (!parsed) parsed = parseVancouver(clean);
                if (!parsed) parsed = parseAPA(clean);
                
                if (!parsed) {
                    htmlRes.push(`<div class="text-red-600 bg-red-50 p-2 rounded mb-2">[Error] 第 ${idx+1} 行格式无法识别</div>`);
                    plainRes.push(`[ERROR] Line ${idx+1}: Unknown format.`);
                } else {
                    let res = formatGBTCitation(parsed, idx + 1);
                    htmlRes.push(`<div class="mb-2 p-2 hover:bg-gray-100 rounded transition">${res.html}</div>`);
                    plainRes.push(res.plain);
                    bibRes.push(formatBibTeX(parsed, idx+1));
                }
            });
            
            document.getElementById('output-content-html').innerHTML = htmlRes.join('');
            document.getElementById('output-content-text').value = plainRes.join('\n');
            document.getElementById('output-bibtex').innerText = bibRes.join('\n\n');
            document.getElementById('output-container').classList.remove('hidden');
        }

        function convertManual() {
            const data = {
                authors: document.getElementById('man-author').value,
                title: document.getElementById('man-title').value,
                source: document.getElementById('man-source').value,
                year: document.getElementById('man-year').value,
                vol: document.getElementById('man-vol').value,
                pages: document.getElementById('man-pages').value,
                type: document.getElementById('man-type').value,
                city: document.getElementById('man-city').value,
                publisher: document.getElementById('man-publisher').value
            };
            
            let res = formatGBTCitation(data, 1);
            document.getElementById('output-content-html').innerHTML = `<div class="p-2">${res.html}</div>`;
            document.getElementById('output-content-text').value = res.plain;
            document.getElementById('output-bibtex').innerText = formatBibTeX(data, 1);
            document.getElementById('output-container').classList.remove('hidden');
        }

        function copyOutput(id) {
            let content = id === 'output-content-text' ? document.getElementById(id).value : document.getElementById(id).innerText;
            navigator.clipboard.writeText(content).then(() => alert("复制成功！"));
        }

        function loadDemo() {
            document.getElementById('input-raw').value = `Acebes, Cesar, et al. "The centerline-cross entropy loss for vessel-like structure segmentation: Better topology consistency without sacrificing accuracy." International Conference on Medical Image Computing and Computer-Assisted Intervention. Cham: Springer Nature Switzerland, 2024.
Quinn, Laura, et al. "Interobserver variability studies in diagnostic imaging." The British Journal of Radiology 96.1148 (2023): 20220972.`;
        }
    </script>
</body>
</html>